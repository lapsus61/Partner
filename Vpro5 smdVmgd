00010 REM * routine visualizzazione grid-			
00020 REM * Rd e Partner  : ps-			
00030 REM ================================================================-			
00040 REM ===init=========================================================-			
00050 REM ================================================================-			
00060 SUB_INITGRD: 			
00070 SETESC SUBESC; SETERR SUBERR			
00080 ENTER SYSGUI,ACT_CTX,GRID_ID,TOT_ROW,TOT_COL,GCHD$[ALL]			
00090 PRINT (SYSGUI)'CONTEXT'(ACT_CTX),			
00100 GOSUB SUB_LOAD_CUSTOM_UTENTE			
00110 REM --Grid----------------------------------			
00120 DIM GRID_C$:TMPL(SYSGUI,IND=1)			
00130 REM --Set #colonne--------------------------			
00140 LET APP$=SENDMSG(SYSGUI,GRID_ID,67,0,$$); 	REM nr row-		
00150 LET APP$=SENDMSG(SYSGUI,GRID_ID,66,TOT_COL,$$); 	REM nr col-		
00160 LET APP$=SENDMSG(SYSGUI,GRID_ID,67,TOT_ROW,$$); 	REM nr row-		
00170 REM --Set image list------------------------			
00180 IF LEN(GCHD$[0])=0 THEN LET GCHD$[0]="10000014immaginelist1.bmp"; 	REM dfl-		
00190 IF LEN(GCHD$[0])<>0 THEN LET IMG_ID=NUM(GCHD$[0](1,5)),IMG_STEP=NUM(GCHD$[0](6,3)),IMG_FLN$=GCHD$[0](9); PRINT (SYSGUI)'ILISTDEL'(IMG_ID),'IMAGELIST'(IMG_ID,IMG_STEP,IMG_FLN$); LET TF$=SENDMSG(SYSGUI,GRID_ID,75,IMG_ID,$$)			
00200 REM --Set header colonne--------------------			
00210 GOSUB SUB_SET_HEADER_COL			
00220 REM ....Reset stbl GridId/Indice/Direzione         ..........-			
00230 LET APP$=STR(0:"00000")+STR(0:"000")+" "			
00240 LET APP$=STBL("grid_sort",APP$)			
00250 GOTO USCITA			
00500 REM 500,5-			
00505 REM ================================================================-			
00510 REM ===show ========================================================-			
00515 REM ================================================================-			
00520 SUB_SHOWGRD: 			
00525 SETESC SUBESC; SETERR SUBERR			
00530 ENTER SYSGUI,ACT_CTX,GRID_ID,TOT_ROW,GDAT$[ALL],GCPS$[ALL]			
00535 IF GRID_ID=0 THEN GOTO USCITA; 	REM activation-		
00540 IF TOT_ROW=0 THEN GOTO USCITA; 	REM >05/08/2024 .. sarà giusta ??-		
00545 LET ORG_ROW_SHOW=TOT_ROW; 	REM memorizzo righe originali in ingresso-		
00550 L65: TABLE FF 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2E 2D 2C 2F 			
00555 DEF FND10$(X$)=X$(7,2)+"/"+X$(5,2)+"/"+X$(1,4)			
00560 DEF FND8$(X$)=X$(7,2)+"/"+X$(5,2)+"/"+X$(3,2)			
00565 DEF FND14$(X$)=X$(7,2)+"/"+X$(5,2)+"/"+X$(1,4)+"-"+X$(9,2)+":"+X$(11,2)+":"+X$(13,2)			
00570 DEF FND19$(X$)=X$(1,1)+"-"+X$(8,2)+"/"+X$(6,2)+"/"+X$(2,4)+"-"+X$(10,6)+"-"+X$(16,4)			
00575 DEF FND97$(X$)=X$(1,2)+":"+X$(3,2)+":"+X$(5,2)			
00580 LET GRID_SORT$=STBL("grid_sort")			
00585 IF NUM(GRID_SORT$(1,5))=GRID_ID THEN GOTO 0605			
00590 REM ....Reset stbl GridId/Indice/Direzione         ..........-			
00595 LET APP$=STR(GRID_ID:"00000")+STR(0:"000")+" "			
00600 LET APP$=STBL("grid_sort",APP$)			
00605 PRINT (SYSGUI)'CONTEXT'(ACT_CTX),			
00610 REM ==no!!legge ogni volta la testata gchd etc==================-			
00615 GOTO 0680; 	REM              IF POS($0A$=GDAT$[1,1])=0 AND POS($09$=GDAT$[1,1])=0 THEN GOTO 0425; REM if per verifxre se gdat $09$0A-		
00620 LET CV_FLG=1; 	REM                            flag dati $09$/$0A$-		
00625 LET CV_DAT$=GDAT$[1,1]; 	REM             completo di testata+dati  -		
00630 LET D_IN$=""+CV_DAT$; 	REM         evita che carichi i dati   -		
00635 CALL "sm2_utl",D_IN$,TESTATA$,CV_OUT$[ALL]; 	REM estraggo testata-		
00640 LET CV_DAT$=CV_DAT$(POS($0A$=CV_DAT$)+1); 	REM      estraggo dati -		
00645 DIM CV_REC$:"cpo[100]:c(500*=9)"; 	REM      template di appoggio-		
00650 LET TOT_COL=POS($09$=TESTATA$,1,0); 	REM           numero colonne-		
00655 DIM GCHD$[1],CV_A$[1,2]; 	REM                                 dim-		
00660 LET CV_A$[0,1]=STR(POS($0A$=CV_DAT$,1,0)); 	REM nr row per setgrid-		
00665 LET CV_A$[0,2]=STR(TOT_COL); 	REM               nr col per setgrid-		
00670 CALL "sm2_utl::set_grid",TESTATA$,CV_A$[ALL],GCHD$[ALL],GCPS$[ALL],0,0			
00675 GOSUB SUB_SET_HEADER_COL			
00680 REM ============================================================-			
00685 GOSUB GET_GRID_INFORMATION			
00690 GOSUB SUB_LOAD_CUSTOM_UTENTE			
00695 REM - Verifico la dimensione della matrice gdat per tot_col ----			
00700 REM - poichè in alcuni casi tot_col non è corretta          ----			
00705 CALL "rbgcmt::SUB_COLROW_MAT",GDAT$[ALL],G_1,G_ROW,G_COL,G_2,G_3,G_4,G_5			
00710 SHOW_GATE_ROUTINE: 			
00715 REM ======================Caratteristiche Colonna========================-			
00720 REM GCPS$[1]=x yy frc:zzzzzz bkc:wwwwww Bnf:Filenm_par:parnm Iog:xxx-			
00725 REM          |  !   !        !           |  |     |    |     +-Key Iog-			
00730 REM          |  !   !        !           |  |     |    |-			
00735 REM          |  !   !        !           |  |     |    Nome paragrafo-			
00740 REM          |  !   !        !           |  |     +--Ind.Iniz.Paragr.-			
00745 REM          |  !   !        !           |  +---- Nome file-			
00750 REM          |  !   !        !           +------- Indicatore LB echo-			
00755 REM          |  !   !        !  -			
00760 REM          |  !   +--------+-- Color     3Byte forecolor + 3bytebackcolor-			
00765 REM          |  +------------- Style                          -			
00766 REM          |                 4 checked box-			
00770 REM          |                 8 unchecked box-			
00775 REM          |                90 rord(n-nn/nn/nnnn-nnnnnn-nnnn)-			
00780 REM          |                91 data gg/mm/aaaa-			
00785 REM          |                92 data gg/mm/aa-			
00790 REM          |                96 data gg/mm/aaaa-hh:mm:ss-			
00795 REM          |                97 ora hh:mm:ss-			
00800 REM          |                98 periodo mm/aaaa (enter aaaamm)-			
00805 REM          |                xy Interi + Decimali se numerico-			
00810 REM          +--- Alignment/Type-			
00815 REM          |    0=Sx (Alfanumerici)-			
00820 REM          |    1=Dx (se campo Numerico e <0 in rosso )-			
00825 REM          |    2=Centro-			
00830 REM          |    3=Campo Numerico Dx  - se <0 in rosso   +'%'-			
00835 REM          |    4=Campo Numerico Dx  - se <0 in rosso se 0 null -			
00840 REM          |    5=Campo Numerico Dx  - come 1 ma se 0 la riga non appare -			
00845 REM -			
00850 REM Color-			
00855 REM definire il valore di red/grn/blu in color map di un pgm carattere-			
00860 REM          determinare il valore esadecimale con hta(chr(numero))-			
00865 REM          esempio grigio=128,128,128-			
00870 REM          hta(chr(128))=80    color = $808080$-			
00875 REM    ... altre ..................................-			
00880 REM    Hide:     Colonna non visibile e non stampabile(set larghezza 0)-			
00885 REM    Mne:xxx   Nome campo associato alla col (fino alla fine o next  )-			
00890 REM ======================Caratteristiche Cella==========================-			
00895 REM Riconoscibile da ' '   nella cella al termine dei dati-			
00900 REM                  'img:'  immagine associata -			
00905 REM                  'frc:'  colore foreground-			
00910 REM                  'bkc:'  colore background-			
00915 REM                  'rwh:'  altezza riga in pixel (0 se invisibile) - va settato solo nella prima cella della riga-			
00920 REM =====================================================================-			
00925 LET MASKERA$="###,###,###,##0"			
00930 REM --Grid----------------------------------			
00935 DIM GRID_C$:TMPL(SYSGUI,IND=1)			
00940 LET APP$=SENDMSG(SYSGUI,GRID_ID,67,MAX(TOT_ROW,ROW_VIS),$$); 	REM nr row-		
00945 REM ---Show---------------------------------			
00950 DIM ECHO_LB_TMP$[TOT_COL]			
00955 REM ---gcps deve essere almeno 9-			
00960 FOR COL=1 TO TOT_COL			
00965 IF LEN(GCPS$[COL])<40 THEN LET GCPS$[COL]=GCPS$[COL]+FILL(40,"0"); LET GCPS$[COL]=GCPS$[COL](1,40)			
00970 NEXT COL			
00975 REM ---colonne nascoste          -			
00980 FOR COL=1 TO TOT_COL			
00985 IF POS("Hide:"=GCPS$[COL])>0 THEN LET TF$=SENDMSG(SYSGUI,GRID_ID,36,COL-1,BIN(0,2))			
00990 NEXT COL			
00995 REM =======>Verifica se DatiD e Switch speciali - Set variabili<=========-			
01000 LET CV_FLG=0,CV_HZ=0			
01005 IF TOT_COL<3 THEN GOTO 1050			
01010 IF POS(""=GDAT$[0,3])=0 THEN GOTO 1050			
01015 LET CV_FLG=1; 	REM                                 SI:flag dati $09$/$0A$-		
01020 LET CV_DAT$=GDAT$[1,1]; 	REM              Legge Matrice in ingresso> Dati-		
01025 LET CV_ELE1$=GDAT$[0,1]; 	REM                                       Righe-		
01030 LET CV_ELE2$=GDAT$[0,2]; 	REM                                     Colonne-		
01035 LET CV_ELE3$=GDAT$[0,3]; 	REM                                      Switch-		
01040 DIM CV_REC$:"cpo[100]:c(500*=9)"; 	REM          Crea Template di appoggio-		
01045 IF POS("HideZero><"=GDAT$[0,3])>0 THEN LET CV_HZ=1; 	REM  Switch HideZero-		
01050 REM ======>Show<=========================================================-			
01055 FOR ROW=ROW_TOP TO MIN(ROW_TOP+ROW_VIS-1,TOT_ROW)			
01060 REM ==16/3/2020==CoronaVirus Test : voglio utilizzare dout %09$/$0A$=====-			
01065 IF CV_FLG=0 THEN GOTO 1115; 	REM non sono entrato con dout$ ma con gdat$[]-		
01070 LET CV_SIC=ROW; 	REM                                Store valore originale-		
01075 DIM GDAT$[1,TOT_COL]; 	REM dim un gdat$ cosi da non dover modificare tutto-		
01080 LET CV_S=0; IF ROW<>1 THEN LET CV_S=POS($0A$=CV_DAT$,1,ROW-1); 	REM  Start-		
01085 LET CV_E=POS($0A$=CV_DAT$,1,ROW); 	REM $0a$                            End-		
01090 LET CV_REC$=CV_DAT$(CV_S+1,CV_E-CV_S-1)+FILL(100,$09$); 	REM Recupera dati-		
01095 FOR CV_C=1+CV_HZ TO TOT_COL; 	REM                   Se HideZero parte da 2-		
01100 LET GDAT$[1,CV_C-CV_HZ]=CV_REC.CPO$[CV_C]; 	REM           Swap se HideZero-		
01105 NEXT CV_C			
01110 LET ROW=1; 	REM            Set il numero riga a 1 fisso perchè dopo lo usa-		
01115 REM =======================================================================-			
01120 REM  FOR COL=1 TO TOT_COL; LET APP_DAT$=APP_DAT$+CVS(GDAT$[ROW,COL],3); NEXT COL; IF LEN(APP_DAT$)=0 THEN GOTO LABEL_NEXT_ROW-			
01125 REM ----- scarto righe vuote e righe '5' con zero -------------------------			
01130 REM -----  verifico la dimensione della matrice gdat per tot_col -			
01135 REM -----  poichè in alcuni casi tot_col non è corretta -------------------			
01140 REM  "rbgcmt::SUB_COLROW_MAT",GDAT$[ALL],G_1,G_ROW,G_COL,G_2,G_3,G_4,G_5-			
01145 LET APP_DAT$=""; FOR COL=1 TO G_COL; LET APP_DAT$=APP_DAT$+CVS(GDAT$[ROW,COL],3); NEXT COL; IF LEN(APP_DAT$)=0 THEN GOTO LABEL_NEXT_ROW			
01150 LET APP_DAT$=""; FOR COL=1 TO G_COL; IF GCPS$[COL](1,1)="5" AND NUM(GDAT$[ROW,COL])=0 THEN LET APP_DAT$=APP_DAT$+GDAT$[ROW,COL] FI; NEXT COL; IF LEN(APP_DAT$)<>0 THEN GOTO LABEL_NEXT_ROW			
01155 REM -----------------------------------------------------------------------			
01160 LET GRID_C.BUF$=""			
01165 LET GRID_C.ROW%=ROW-1			
01170 IF CV_FLG=1 THEN LET GRID_C.ROW%=CV_SIC-1; 	REM Reale nr riga se -		
01175 FOR COL=1 TO G_COL; 	REM      reale dimensione di gdat     TOT_COL-		
01180 LET GRID_C.COL%=COL-1			
01185 LET IMG_BUF$=GDAT$[ROW,COL]			
01190 LET APP=POS(" "=GDAT$[ROW,COL]); IF APP>0 THEN IF APP>1 THEN LET GDAT$[ROW,COL]=GDAT$[ROW,COL](1,APP-1) ELSE LET GDAT$[ROW,COL]=""			
01195 REM ---verifica se immagine associata----------------------------------			
01200 LET IMG_IDX=0			
01205 LET APP=POS("img:"=IMG_BUF$)			
01210 IF LEN(IMG_BUF$)<APP+6 THEN LET APP=0; GOTO 1225			
01215 IF IMG_BUF$(APP+4,3)<"000" OR IMG_BUF$(APP+4,3)>"999" THEN LET APP=0			
01220 IF APP>0 THEN LET IMG_IDX=NUM(IMG_BUF$(APP+4,3))			
01225 REM ---Controlla se echo list button   Si=Open e lettura paragrafo---			
01230 LET B=POS("Bnf:"=GCPS$[COL]); IF B=0 THEN GOTO 1275			
01235 IF ROW<>ROW_TOP THEN GOTO 1275			
01240 LET ECHO_LB_CHN=UNT			
01245 LET ECHO_LB_FLN$=GCPS$[COL](B+4,POS("_par:"=GCPS$[COL](B))-B+5)			
01250 LET ECHO_LB_PAR$=GCPS$[COL](POS("_par:"=GCPS$[COL])+5)			
01255 OPEN (ECHO_LB_CHN)ECHO_LB_FLN$			
01260 CALL "rbglbt::sub_load_lb",ECHO_LB_FLN$,ECHO_LB_PAR$,".txt",TMP$,ECHO_LB_CHN			
01265 LET ECHO_LB_TMP$[COL]=TMP$			
01270 CLOSE (ECHO_LB_CHN)			
01275 REM ---Controlla colore intera colonna----------------------------------			
01280 IF GCPS$[COL](4,3)="000" THEN LET GCPS$[COL](4,3)=$0000FF$			
01285 IF GCPS$[COL](7,3)="000" THEN LET GCPS$[COL](7,3)=$FFFFFF$			
01290 LET GRID_C.TEXTCOLOR$=GCPS$[COL](4,3),GRID_C.BACKCOLOR$=GCPS$[COL](7,3)			
01295 REM ---Controlla colore singolo campo-----------------------------------			
01300 LET APP=POS("frc:"=IMG_BUF$); IF APP>0 THEN LET GRID_C.TEXTCOLOR$=IMG_BUF$(APP+4,3)			
01305 LET APP=POS("bkc:"=IMG_BUF$); IF APP>0 THEN LET GRID_C.BACKCOLOR$=IMG_BUF$(APP+4,3)			
01310 REM --------------------------------------------------------------------			
01315 IF POS(GCPS$[COL](1,1)="1345")=0 THEN GOTO 1390			
01320 IF POS("-"=GDAT$[ROW,COL])>0 THEN LET GRID_C.TEXTCOLOR$=$FF0000$; 	REM rosso su negativi numerici-		
01325 REM --- se più di 9 interi            -			
01330 LET APP=POS(GCPS$[COL](2,1)="ABCDE")			
01335 IF APP=0 THEN LET MASK_INT=NUM(GCPS$[COL](2,1)) ELSE LET MASK_INT=9+APP			
01340 LET MASK_DEC=NUM(GCPS$[COL](3,1))			
01345 IF MASK_INT=0 THEN GOTO 1390			
01350 LET APP_MASK$="-"+MASKERA$(16-MASK_INT); IF MASK_DEC<>0 THEN LET APP_MASK$=APP_MASK$+"."+FILL(MASK_DEC,"0")			
01355 LET MASK_NUM=NUM(GDAT$[ROW,COL])			
01360 IF MASK_NUM=0 AND LEN(CVS(GDAT$[ROW,1],3))=0 THEN GOTO 1385			
01365 LET GRID_C.BUF$=TBL(STR(MASK_NUM:APP_MASK$),TBL=L65)			
01370 IF GCPS$[COL](1,1)="3" THEN LET GRID_C.BUF$=GRID_C.BUF$+"%"			
01375 IF GCPS$[COL](1,1)="4" AND MASK_NUM=0 THEN LET GRID_C.BUF$=""			
01380 LET GRID_C.STYLE=0			
01385 GOTO 1425			
01390 REM --------------------------------------------------------			
01395 LET GRID_C.BUF$=GDAT$[ROW,COL]			
01400 IF LEN(ECHO_LB_TMP$[COL])=0 THEN GOTO 1415			
01405 LET APP=POS(GRID_C.BUF$=ECHO_LB_TMP$[COL]); IF APP=0 THEN GOTO 1415			
01410 LET GRID_C.BUF$=ECHO_LB_TMP$[COL](APP,POS($0A$=ECHO_LB_TMP$[COL](APP)))			
01415 REM --------------------------------------------------------			
01420 LET GRID_C.STYLE=NUM(GCPS$[COL](2,2))			
01425 REM --------------------------------------------------------			
01430 LET GRID_C.ALIGNMENT=NUM(GCPS$[COL](1,1))			
01435 IF POS(GCPS$[COL](1,1)="345")>0 THEN LET GRID_C.ALIGNMENT=1			
01440 IF POS(GCPS$[COL](1,1)="5")>0 THEN LET GRID_C.STYLE=0			
01445 IF GRID_C.STYLE=90 THEN LET GRID_C.STYLE=0,GRID_C.BUF$=FND19$(GRID_C.BUF$+FILL(19," ")); GOTO 1485			
01450 IF GRID_C.STYLE=91 THEN LET GRID_C.STYLE=0; IF LEN(CVS(GRID_C.BUF$,3))=8 THEN LET GRID_C.BUF$=FND10$(GRID_C.BUF$); GOTO 1485			
01455 IF GRID_C.STYLE=92 THEN LET GRID_C.STYLE=0; IF LEN(CVS(GRID_C.BUF$,3))=8 THEN LET GRID_C.BUF$=FND8$(GRID_C.BUF$); GOTO 1485			
01460 IF GRID_C.STYLE=96 THEN LET GRID_C.STYLE=0; IF LEN(CVS(GRID_C.BUF$,3))=14 THEN LET GRID_C.BUF$=FND14$(GRID_C.BUF$); GOTO 1485			
01465 IF GRID_C.STYLE=97 THEN LET GRID_C.STYLE=0; IF LEN(CVS(GRID_C.BUF$,3))=6 THEN LET GRID_C.BUF$=FND97$(GRID_C.BUF$); GOTO 1485			
01470 IF GRID_C.STYLE=98 THEN LET GRID_C.STYLE=0; IF LEN(CVS(GRID_C.BUF$,3))=6 THEN LET GRID_C.BUF$=GRID_C.BUF$(5,2)+"/"+GRID_C.BUF$(1,4); GOTO 1485			
01475 IF GRID_C.STYLE=8 AND GDAT$[ROW,COL]="Y" THEN LET GRID_C.STYLE=4,GRID_C.BUF$=""; GOTO 1485			
01480 IF GRID_C.STYLE=8 AND GDAT$[ROW,COL]<>"Y" THEN LET GRID_C.BUF$=""; GOTO 1485			
01485 REM ...-			
01490 LET GRID_C.IMGIDX=999; IF IMG_IDX<>0 THEN LET GRID_C.IMGIDX=IMG_IDX-1			
01495 LET RESULT$=SENDMSG(SYSGUI,GRID_ID,54,0,GRID_C$)			
01500 LET GDAT$[ROW,COL]=IMG_BUF$			
01505 NEXT COL			
01510 REM qui va messo la larghezza 0 se colonne Hide (vedi SUB_SET_COL_SIZE)-			
01515 LABEL_NEXT_ROW: 			
01520 REM ==================CV=======================================-			
01525 IF CV_FLG=1 THEN LET ROW=CV_SIC; 	REM Ripristina numero riga originale-		
01530 NEXT ROW			
01535 SWITCH CV_FLG			
01540 CASE 0; BREAK			
01545 CASE 1; 	REM Ripristino matrice in ingresso-		
01550 LET GDAT$[1,1]=CV_DAT$			
01555 LET GDAT$[0,1]=CV_ELE1$			
01560 LET GDAT$[0,2]=CV_ELE2$			
01565 LET GDAT$[0,3]=CV_ELE3$			
01570 BREAK			
01575 SWEND			
01580 REM GOSUB GET_GRID_INFORMATION; GOSUB SUB_SET_COL_SIZE; LET TOT_ROW=ORG_ROW_SHOW-			
01585 GOTO USCITA			
05000 REM 5000,5-			
05005 REM ================================================================-			
05010 REM ===sort=========================================================-			
05015 REM ================================================================-			
05020 SUB_SORTGRD: 			
05025 SETESC SUBESC; SETERR SUBERR			
05030 ENTER SYSGUI,ACT_CTX,GRID_ID,GDAT$[ALL],GCPS$[ALL]			
05035 PRINT (SYSGUI)'CONTEXT'(ACT_CTX),			
05040 GOSUB GET_GRID_INFORMATION			
05045 REM  GOSUB GET_LAST_NO_EMPTY_ROW                 GG 13/02/2025-			
05050 REM  T_CTR=LAST_NEROW; REM ultima riga non vuota-			
05055 REM  TOT_ROW=T_CTR --------------------------------------------			
05060 GOSUB SUB_LOAD_CUSTOM_UTENTE			
05065 DIM DIMENSION$:"dimen:i(1),d0elem:i(4),d0base:i(4),d1elem:i(4),d1base:i(4),d2elem:i(4),d2base:i(4)"			
05070 LET DIMENSION$=DIMS(GDAT$[ALL])			
05075 LET NR_RIG=DIMENSION.D0ELEM-1			
05080 LET TOT_ROW=DIMENSION.D0ELEM-1			
05085 LET TOT_COL=DIMENSION.D1ELEM-1			
05090 LET T_CTR=TOT_ROW			
05095 GOSUB GET_LAST_NO_EMPTY_ROW			
05100 LET TOT_ROW=LAST_NEROW			
05105 LET T_CTR=LAST_NEROW			
05110 LET GDAT_ORG$[ALL]=GDAT$[ALL]			
05115 DIM GDAT$[NR_RIG,TOT_COL]			
05120 REM ......Parametri image............................................-			
05125 LET BI=698,BX=150,BY=100,BW=100,BH=30,BI$="env4a-"			
05130 REM .................................................................-			
05135 PRINT (SYSGUI)'TBUTTON'(BI,BX,BY,BW,BH,"BITMAP="+BI$+"00.bmp",$$)			
05140 LET GRID_SORT$=STBL("grid_sort",ERR=5210)			
05145 IF NUM(GRID_SORT$(1,5))<>GRID_ID THEN GOTO 5210			
05150 IF NUM(GRID_SORT$(6,3))<>INDICE THEN GOTO 5210			
05155 REM ------------------------------------------------------			
05160 REM ---Grid/Indice gia' sortati : devo solo invertire ----			
05165 REM ------------------------------------------------------			
05170 IF GRID_SORT$(9,1)="<" THEN LET SORT_IND$=">"			
05175 IF GRID_SORT$(9,1)=">" THEN LET SORT_IND$="<"			
05180 REM ---Store.............................................-			
05185 LET CTR_BMP=0			
05190 LET STP_BMP=INT(T_CTR/(10-CTR_BMP-1))			
05195 LET EL2=T_CTR			
05200 FOR ELE=1 TO T_CTR; FOR COL=0 TO TOT_COL; LET GDAT$[ELE,COL]=GDAT_ORG$[EL2,COL]; NEXT COL; LET EL2=EL2-1; IF STP_BMP>1 AND FPT(ELE/STP_BMP)=0 THEN LET CTR_BMP=MIN(CTR_BMP+1,9),FILE_BMP$=BI$+STR(CTR_BMP:"00")+".bmp"; PRINT (SYSGUI)'DESTROY'(BI),'TBUTTON'(BI,BX,BY,BW,BH,"BITMAP="+FILE_BMP$,$$) FI; NEXT ELE			
05205 GOTO 5525			
05210 REM ------------------------------------------------------			
05215 REM ---Primo sort su questa grid/indice : eseguo      ----			
05220 REM ------------------------------------------------------			
05225 LET SORT_IND$="<"			
05230 REM ---Determina step ssort (mx len elemento colonna.....-			
05235 LET MX_LEN=0			
05240 FOR ELE=1 TO T_CTR; IF LEN(GDAT_ORG$[ELE,INDICE])>MX_LEN THEN LET MX_LEN=LEN(GDAT_ORG$[ELE,INDICE]) FI; NEXT ELE			
05245 PRINT (SYSGUI)'DESTROY'(BI),'TBUTTON'(BI,BX,BY,BW,BH,"BITMAP="+BI$+"01.bmp",$$)			
05250 REM ---Set stringa per sort..............................-			
05255 LET STR_ORG$=""			
05260 FOR ELE=1 TO T_CTR; LET APP$=GDAT_ORG$[ELE,INDICE]+FILL(MX_LEN," "),APP$=APP$(1,MX_LEN),STR_ORG$=STR_ORG$+APP$; NEXT ELE			
05265 PRINT (SYSGUI)'DESTROY'(BI),'TBUTTON'(BI,BX,BY,BW,BH,"BITMAP="+BI$+"02.bmp",$$)			
05270 REM =====================================================================-			
05275 REM ----- tento di formattarli come se si trattasse di numeri---------   -			
05280 LET COPY_OF_STR_ORG$=STR_ORG$,STR_ORG$="",MX_LEN_ORG=MX_LEN			
05285 LET MX_LEN=26			
05290 IF MX_LEN_ORG=0 THEN PRINT (SYSGUI)'DESTROY'(BI),'FLUSH'; GOTO USCITA			
05295 FOR ELE=1 TO LEN(COPY_OF_STR_ORG$) STEP MX_LEN_ORG			
05300 SETERR 5320			
05305 LET APP=NUM(COPY_OF_STR_ORG$(ELE,MX_LEN_ORG)),CTR_E=ELE			
05310 LET APP$=STR(APP:"+000000000000000000.000000"); IF APP$(1,1)="-" THEN LET APP$=STR(1000000000000000+APP:"+000000000000000000.000000"),APP$=CHR(28)+APP$(2)			
05315 LET STR_ORG$=STR_ORG$+APP$			
05320 SETERR SUBERR			
05325 IF CTR_E<>ELE THEN EXITTO 5335			
05330 NEXT ELE			
05335 SETERR SUBERR			
05340 IF ELE<LEN(COPY_OF_STR_ORG$) THEN LET STR_ORG$=COPY_OF_STR_ORG$,MX_LEN=MX_LEN_ORG			
05345 LET STRINGA$=SSORT(STR_ORG$,MX_LEN)			
05350 GOTO 5460; 	REM nuova routine 13/11/2016-		
05355 REM =====================================================================-			
05360 IF MX_LEN>14 THEN GOTO 5440; 	REM non numerico-		
05365 LET COPY_OF_STR_ORG$=STR_ORG$,SS_M$=FILL(MX_LEN-1,"0"),APP$=FILL(MX_LEN-1,"9"),SS_1=NUM(APP$)			
05370 REM ..Loop search "-"-			
05375 LET SS_2=POS("-"=STR_ORG$); IF SS_2=0 THEN GOTO 5440			
05380 LET SS_3=INT((SS_2+MX_LEN-1)/MX_LEN)*MX_LEN-(MX_LEN-1)			
05385 LET APP$=STR_ORG$(SS_3,MX_LEN)			
05390 REM ..Elimina ","-			
05395 LET APP=POS(","=APP$); IF APP>0 THEN LET APP$(APP,1)="0"; GOTO 5395			
05400 REM ..Elimina "."-			
05405 LET APP=POS("."=APP$); IF APP>0 THEN LET APP$(APP,1)="0"; GOTO 5405			
05410 LET SS_4=NUM(APP$,ERR=5425)			
05415 LET STR_ORG$(SS_3,MX_LEN)=CHR(28)+STR(SS_1+SS_4:SS_M$)			
05420 GOTO 5370			
05425 REM ..Uno degli elementi non e' numerico : Ripristino-			
05430 LET STR_ORG$=COPY_OF_STR_ORG$			
05435 REM ...-			
05440 REM ...-------------------------------------------------			
05445 REM ...-			
05450 REM ...-			
05455 LET STRINGA$=SSORT(STR_ORG$,MX_LEN)			
05460 PRINT (SYSGUI)'DESTROY'(BI),'TBUTTON'(BI,BX,BY,BW,BH,"BITMAP="+BI$+"03.bmp",$$)			
05465 REM ---Store.............................................-			
05470 LET CTR_BMP=3; 	REM ultima bmp gia utilizzata-		
05475 LET STP_BMP=INT(T_CTR/(10-CTR_BMP-1)); 	REM mi riservo env4-10 per ultimo-		
05480 FOR ELE=1 TO T_CTR			
05485 LET POS_ELE=ELE*MX_LEN-(MX_LEN-1)			
05490 LET EL1=POS(STRINGA$(POS_ELE,MX_LEN)=STR_ORG$,MX_LEN,1)			
05495 LET EL2=(EL1+(MX_LEN-1))/MX_LEN			
05500 FOR COL=0 TO TOT_COL; LET GDAT$[ELE,COL]=GDAT_ORG$[EL2,COL]; NEXT COL			
05505 IF STP_BMP>1 AND FPT(ELE/STP_BMP)=0 THEN LET CTR_BMP=MIN(CTR_BMP+1,9),FILE_BMP$=BI$+STR(CTR_BMP:"00")+".bmp"; PRINT (SYSGUI)'DESTROY'(BI),'TBUTTON'(BI,BX,BY,BW,BH,"BITMAP="+FILE_BMP$,$$)			
05510 REM ..Evita che prenda due volte lo stesso elemento (valori uguali).-			
05515 LET STR_ORG$(EL1,MX_LEN)=FILL(MX_LEN,"*")			
05520 NEXT ELE			
05525 REM -----------------------------------------------------------			
05530 REM ....Ripristina Header col................................-			
05535 REM -----------------------------------------------------------			
05540 PRINT (SYSGUI)'DESTROY'(BI),'TBUTTON'(BI,BX,BY,BW,BH,"BITMAP="+BI$+"10.bmp",$$)			
05545 DIM GRID_C$:TMPL(SYSGUI,IND=1)			
05550 LET APP$=REV; IF APP$(1,4)>="REV 3" THEN GOSUB SUB_SET_HEADER_COL			
05555 REM ....Set stbl con GridId, ultimo indice sortato e direzione-			
05560 LET APP$=STR(GRID_ID:"00000")+STR(INDICE:"000")+SORT_IND$			
05565 LET APP$=STBL("grid_sort",APP$)			
05570 REM ....Erase ...............................................-			
05575 PRINT (SYSGUI)'DESTROY'(BI),'FLUSH'			
05580 GOTO SHOW_GATE_ROUTINE			
05585 REM ================================================================-			
05590 REM ===col resize===================================================-			
05595 REM ================================================================-			
05600 SUB_COLRESIZE: 			
05605 SETESC SUBESC; SETERR SUBERR			
05610 REM la versione 2.23 non gestisce grid sendmsg 89 in get_grid_information-			
05615 REM  Non è quindi in grado di verificare le label delle colonne          -			
05620 REM  Il vettore GCHD$[] deve quindi essere passato con call              -			
05625 REM Non modifico SUBITO tutti i programmi,quindi inserisco le righe      -			
05630 LET RESIZE_E=0; 	REM Enter Senza GCHD$[]                                  -		
05635 ENTER SYSGUI,ACT_CTX,GRID_ID,GDAT$[ALL],GCPS$[ALL],R_HD$[ALL],ERR=5650			
05640 LET RESIZE_E=1; 	REM enter CON GCHD$[] per versione 2.23                  -		
05645 REM ----------------------------------------------------------------------			
05650 LET ACC$=STBL("acc")			
05655 REM -- se chiamato con grid_id negativo,indica il resize di una colonna-			
05660 IF SGN(GRID_ID)=-1 THEN LET GRID_ID=ABS(GRID_ID),PS_RESSINGLE=1			
05665 SUB_COLRESIZE2: 			
05670 PRINT (SYSGUI)'CONTEXT'(ACT_CTX),			
05675 GOSUB GET_GRID_INFORMATION			
05680 IF RESIZE_E=1 THEN LET GCHD$[ALL]=R_HD$[ALL]; 	REM Enter con GCHD$[a]-		
05685 GOSUB GET_ARRAY_INFORMATION; LET T_CTR=TOT_ROW			
05690 GOSUB SUB_LOAD_CUSTOM_UTENTE			
05695 GOSUB SUB_SET_COL_SIZE			
05700 GOTO SHOW_GATE_ROUTINE			
05705 REM ================================================================-			
05710 SUB_SET_COL_SIZE: 			
05715 DIM GB__SYSGUI_FIN$:TMPL(SYSGUI,IND=0)			
05720 LET GB__SYSGUI_FIN$=FIN(SYSGUI)			
05725 LET PS_SCALE_X=GB__SYSGUI_FIN.SCREEN_WIDTH/800			
05730 LET PS_SCALE_Y=GB__SYSGUI_FIN.SCREEN_HEIGHT/600			
05735 REM ..... Il resize è eseguito sempre su tutte le colonne-			
05740 REM ..... smd_mgd quando stringe esegue grid sendmsg 36-			
05745 REM ..... smd_mgd quando allarga richiama questa routine-			
05750 REM .....  ma con grid_id negativo. setto quindi ps_ressingle a 1-			
05755 LET COL_RES_IN=1,COL_RES_FN=TOT_COL			
05760 IF PS_RESSINGLE=1 THEN LET COL_RES_IN=INDICE,COL_RES_FN=INDICE			
05765 REM -----------------------------------------------------------------			
05770 LET TOT_ROW=T_CTR			
05775 DIM GRID_24[TOT_COL]; 	REM Grid24-		
05780 FOR INDICE=COL_RES_IN TO COL_RES_FN			
05785 REM --Determina max len---------------------			
05790 LET MXCL=0			
05795 REM ...Init:len header - esclude switch ...-			
05800 LET PS_A=POS(" "=GCHD$[INDICE])			
05805 IF PS_A=0 THEN LET MXCL=LEN(CVS(GCHD$[INDICE],3)) ELSE LET MXCL=PS_A-2			
05810 REM ...Len dati - esclude switch ..........-			
05815 FOR RW=1 TO TOT_ROW			
05820 LET APP_DAT$=""; FOR APP_COL=1 TO TOT_COL; LET APP_DAT$=APP_DAT$+GDAT$[RW,APP_COL]; NEXT APP_COL; IF LEN(APP_DAT$)=0 THEN EXITTO 5875; 	REM 3/10/2022-		
05825 IF RW=1 AND INDICE=1 AND TOT_COL>2 AND POS(""=GDAT$[0,3])>0 THEN GOTO 5860; 	REM Sa DatiD dovrebbe capire la vera lunghezza del dato contenuto, ma devo saltare 1,1 che contiene tutto-		
05830 LET PS_A=POS(" "=GDAT$[RW,INDICE])			
05835 IF PS_A=1 THEN LET PS_A=0; 	REM Se contiene solo  xxx-		
05840 IF PS_A=0 THEN LET LEN_PXL=LEN(CVS(GDAT$[RW,INDICE],3)) ELSE LET LEN_PXL=LEN(CVS(GDAT$[RW,INDICE](1,PS_A-2),3)); 	REM PS_A-2-		
05845 REM .. considera formattazione se numerici ...-			
05850 IF GCPS$[INDICE](1,1)="1" THEN LET PS_A=NUM(GCPS$[INDICE](2,1))+NUM(GCPS$[INDICE](3,1))+1; LET LEN_PXL=MAX(LEN_PXL,PS_A)			
05855 IF LEN_PXL>MXCL THEN LET MXCL=LEN_PXL			
05860 NEXT RW			
05865 REM -- Mod 27/9/2023 2797 NDICE](3,1))+1 e non +3-			
05870 REM -- Mod 27/9/2023 2860 (COL_WIDTH+2))+20 diventa (COL_WIDTH))+10-			
05875 REM ---Set column width---------------------			
05880 LET GRID_24[INDICE]=MXCL; 	REM Grid24-		
05885 LET LEN_COLONNA=INT((MXCL+3)*(COL_WIDTH+1)); 	REM           *PS_SCALE_X)-		
05890 REM -- Indicatore colonna nascosta ---------			
05895 IF POS("Hide:"=GCPS$[INDICE])>0 THEN LET LEN_COLONNA=0,GRID_24[INDICE]=1			
05900 LET TF$=SENDMSG(SYSGUI,GRID_ID,36,INDICE-1,BIN(LEN_COLONNA,2))			
05905 NEXT INDICE			
05910 REM ---------- 05/02/2025 Best Fit Grid24----------------------			
05915 IF PS_RESSINGLE=1 THEN GOTO 5945			
05920 LET L_24$=""			
05925 FOR APP=1 TO TOT_COL			
05930 LET L_24$=L_24$+FILL(MAX(GRID_24[APP],1),"X")+$0A$			
05935 NEXT APP			
05940 LET TF$=SENDMSG(SYSGUI,GRID_ID,24,10,L_24$)			
05945 REM ...-			
05950 RETURN 			
05955 USCITA: 			
05960 EXIT 			
05965 REM ================================================================-			
05970 REM ===row height===================================================-			
05975 REM ================================================================-			
05980 SUB_ROWHEIGHT: 			
05985 SETESC SUBESC; SETERR SUBERR			
05990 ENTER SYSGUI,ACT_CTX,GRID_ID,GDAT$[ALL]			
05995 PRINT (SYSGUI)'CONTEXT'(ACT_CTX),			
06000 GOSUB GET_GRID_INFORMATION			
06005 GOSUB GET_ARRAY_INFORMATION			
06010 FOR ROW=1 TO TOT_ROW			
06015 IF POS(" "=GDAT$[ROW,1])>0 THEN LET APP=POS("rwh:"=GDAT$[ROW,1]); IF APP>0 THEN LET ROW_H=NUM(GDAT$[ROW,1](APP+1,3)),APP$=SENDMSG(SYSGUI,GRID_ID,68,ROW_H,$$)			
06020 NEXT ROW			
06025 EXIT 			
06030 REM =====================================================================-			
06035 SUB_SET_HEADER_COL: 			
06040 FOR COL=0 TO TOT_COL-1			
06045 LET GRID_C.COL%=COL			
06050 LET GRID_C.ROW%=0			
06055 IF GCHD$[COL+1]="" THEN LET GCHD$[COL+1]="Col"+STR(COL+1)			
06060 LET GRID_C.TEXTCOLOR$=$00FF00$			
06065 LET GRID_C.BACKCOLOR$='RGB'($12$)			
06070 LET GRID_C.BUF$=GCHD$[COL+1]			
06075 LET GRID_C.BUF$=GCHD$[NUM(COL_SEQ$((COL+1)*3-2,3))]; 	REM custom col seq-		
06080 LET GRID_C.ALIGNMENT=0			
06085 LET GRID_C.STYLE=2			
06090 LET RESULT$=SENDMSG(SYSGUI,GRID_ID+1,54,0,GRID_C$)			
06095 NEXT COL			
06100 RETURN 			
06105 REM =====================================================================-			
06110 GET_ARRAY_INFORMATION: 			
06115 DIM DIMENSION$:"dimen:i(1),d0elem:i(4),d0base:i(4),d1elem:i(4),d1base:i(4),d2elem:i(4),d2base:i(4)"			
06120 LET DIMENSION$=DIMS(GDAT$[ALL])			
06125 LET TOT_ROW=DIMENSION.D0ELEM-1			
06130 LET TOT_COL=DIMENSION.D1ELEM-1			
06135 RETURN 			
06140 REM =====================================================================-			
06145 GET_GRID_INFORMATION: 			
06150 LET INDICE=DEC(SENDMSG(SYSGUI,GRID_ID,44,0,$$))+1			
06155 LET TOT_COL=MAX(DEC(SENDMSG(SYSGUI,GRID_ID,40,0,$$)),T_COL)			
06160 DIM GCHD$[TOT_COL]			
06165 REM ...............................................-			
06170 LET APP$=REV; IF APP$(1,5)<"REV 3" THEN GOTO 6205			
06175 FOR CELL=1 TO TOT_COL			
06180 LET GCHD$[CELL]=SENDMSG(SYSGUI,GRID_ID+1,89,CELL-1,$$)			
06185 LET GCHD$[CELL]=CVS(GCHD$[CELL],3)			
06190 LET LEN_HCOL=LEN(GCHD$[CELL])			
06195 IF LEN_HCOL<>0 AND (GCHD$[CELL](LEN_HCOL,1)=">" OR GCHD$[CELL](LEN_HCOL,1)="<") THEN LET GCHD$[CELL]=GCHD$[CELL](1,LEN_HCOL-1)			
06200 NEXT CELL			
06205 LET T_CTR=DEC(SENDMSG(SYSGUI,GRID_ID,41,0,$$))			
06210 LET COL_WIDTH=DEC(SENDMSG(SYSGUI,GRID_ID,37,0,$$))			
06215 LET APP$=SENDMSG(SYSGUI,GRID_ID,44,0,$$); LET COL_SEL=DEC(APP$)+1			
06220 LET APP$=SENDMSG(SYSGUI,GRID_ID,45,0,$$); LET ROW_SEL=DEC(APP$)+1			
06225 LET APP$=SENDMSG(SYSGUI,GRID_ID,43,0,$$); LET ROW_VIS=MIN(DEC(APP$),25)			
06230 LET APP$=SENDMSG(SYSGUI,GRID_ID,43,0,$$); LET ROW_VIS=MIN(DEC(APP$),100)			
06235 LET APP$=SENDMSG(SYSGUI,GRID_ID,46,0,$$); LET ROW_TOP=DEC(APP$)+1			
06240 LET APP$=SENDMSG(SYSGUI,GRID_ID,41,0,$$); LET ROW_MAX=MIN(DEC(APP$),1)			
06245 RETURN 			
06250 REM =====================================================================-			
06255 GET_LAST_NO_EMPTY_ROW: 			
06260 LET LAST_NEROW=0			
06265 FOR APP=1 TO T_CTR; LET APP$=""; FOR CELL=1 TO TOT_COL; LET APP$=APP$+GDAT$[APP,CELL]; NEXT CELL; IF LEN(APP$)<>0 THEN LET LAST_NEROW=APP FI; NEXT APP			
06270 RETURN 			
06275 REM =================================================================-			
06280 REM       *******    N U O V E    R O U T I N E S *******-			
06285 REM     si basano sulla gestione di una matrice utilizzata per la-			
06290 REM     sola visualizzazione e che contiene tutti i dati della   -			
06295 REM     template GRID_C. La matrice e' GRID_MT$[all]-			
06300 REM =================================================================-			
06305 SUB_V2_LOAD_GRID_C: 			
06310 SETESC SUBESC; SETERR SUBERR			
06315 ENTER SYSGUI,VAR1,VAR2,TOT_ROW,GDAT$[ALL],GCPS$[ALL],GRID_MT$[ALL]			
06320 L65: TABLE FF 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2E 2D 2C 2F 			
06325 DEF FND10$(X$)=X$(7,2)+"/"+X$(5,2)+"/"+X$(1,4)			
06330 DIM DIMENSION$:"dimen:i(1),d0elem:i(4),d0base:i(4),d1elem:i(4),d1base:i(4),d2elem:i(4),d2base:i(4)"			
06335 LET DIMENSION$=DIMS(GDAT$[ALL])			
06340 LET TOT_COL=DIMENSION.D1ELEM-1			
06345 GOSUB SUB_LOAD_CUSTOM_UTENTE			
06350 DIM GRID_MT$[TOT_ROW,TOT_COL]			
06355 REM GCPS$[1]=x yy zzzzzz wwwwww Bnf:Filenm_par:parnm-			
06360 REM          !  !   !      !    !      !      !-			
06365 REM          !  !   !      !    !      !      + Nome paragrafo-			
06370 REM          !  !   !      !    !      +------- Nome file-			
06375 REM          !  !   !      !    +-------------- Indicatore LB echo-			
06380 REM          !  !   !      !  -			
06385 REM          !  !   +------+-- Color       3Byte forecolor + 3bytebackcolor-			
06390 REM          !  +------------- Style       4 checked box-			
06395 REM          !                             8 unchecked box-			
06400 REM          !                            91 data gg/mm/aaaa-			
06405 REM          !                            xy Interi + Decimali se numerico-			
06410 REM          +---------------- Alignment   0=Sx (Alfa)-			
06415 REM !                                      1=Dx (Numerico (<0 in rosso))-			
06420 REM !                                      2=Centro-			
06425 LET MASKERA$="###,###,###,##0"			
06430 REM --Grid----------------------------------			
06435 DIM GRID_C$:TMPL(SYSGUI,IND=1)			
06440 REM ---Show---------------------------------			
06445 DIM ECHO_LB_TMP$[TOT_COL]			
06450 FOR COL=1 TO TOT_COL			
06455 IF LEN(GCPS$[COL])<40 THEN LET GCPS$[COL]=GCPS$[COL]+FILL(40,"0"); LET GCPS$[COL]=GCPS$[COL](1,40)			
06460 NEXT COL			
06465 LET STEP_GRIDC=INT(TOT_ROW/20)			
06470 FOR ROW=1 TO TOT_ROW			
06475 IF STEP_GRIDC<>0 AND FPT(ROW/STEP_GRIDC)=0 THEN LET TF$=SENDMSG(GB__SYSGUI,800,20,DEC($0400$),"Caricamento "+STR(ROW/STEP_GRIDC)+"%")			
06480 LET APP_DAT$=""; FOR COL=1 TO TOT_COL; LET APP_DAT$=APP_DAT$+CVS(GDAT$[ROW,COL],3); NEXT COL; IF LEN(APP_DAT$)=0 THEN GOTO LABEL_NEXT_ROW			
06485 LET GRID_C.ROW%=ROW-1			
06490 FOR COL=1 TO TOT_COL			
06495 LET GRID_C.COL%=COL-1			
06500 LET IMG_BUF$=GDAT$[ROW,COL]			
06505 LET APP=POS(" "=GDAT$[ROW,COL]); IF APP>0 THEN IF APP>1 THEN LET GDAT$[ROW,COL]=GDAT$[ROW,COL](1,APP-1) ELSE LET GDAT$[ROW,COL]=""			
06510 REM ---verifica se immagine associata----------------------------------			
06515 LET IMG_IDX=0			
06520 LET APP=POS("img:"=IMG_BUF$); IF APP>0 THEN LET IMG_IDX=NUM(IMG_BUF$(APP+4,3))			
06525 REM ---Controlla se echo list button   Si=Open e lettura paragrafo---			
06530 LET B=POS("Bnf:"=GCPS$[COL]); IF B=0 THEN GOTO 6575			
06535 IF ROW<>ROW_TOP THEN GOTO 6575			
06540 LET ECHO_LB_CHN=UNT			
06545 LET ECHO_LB_FLN$=GCPS$[COL](B+4,POS("_par:"=GCPS$[COL](B))-B+5)			
06550 LET ECHO_LB_PAR$=GCPS$[COL](POS("_par:"=GCPS$[COL])+5)			
06555 OPEN (ECHO_LB_CHN)ECHO_LB_FLN$			
06560 CALL "rbglbt::sub_load_lb",ECHO_LB_FLN$,ECHO_LB_PAR$,".txt",TMP$,ECHO_LB_CHN			
06565 LET ECHO_LB_TMP$[COL]=TMP$			
06570 CLOSE (ECHO_LB_CHN)			
06575 REM --------------------------------------------------------------------			
06580 IF GCPS$[COL](4,3)="000" THEN LET GCPS$[COL](4,3)=$0000FF$			
06585 IF GCPS$[COL](7,3)="000" THEN LET GCPS$[COL](7,3)=$FFFFFF$			
06590 LET GRID_C.TEXTCOLOR$=GCPS$[COL](4,3),GRID_C.BACKCOLOR$=GCPS$[COL](7,3)			
06595 IF GCPS$[COL](1,1)<>"1" AND GCPS$[COL](1,1)<>"3" THEN GOTO 6665			
06600 IF POS("-"=GDAT$[ROW,COL])>0 THEN LET GRID_C.TEXTCOLOR$=$FF0000$; 	REM rosso su negativi numerici-		
06605 REM --- se più di 9 interi            -			
06610 LET APP=POS(GCPS$[COL](2,1)="ABCDE")			
06615 IF APP=0 THEN LET MASK_INT=NUM(GCPS$[COL](2,1)) ELSE LET MASK_INT=9+APP			
06620 LET MASK_DEC=NUM(GCPS$[COL](3,1))			
06625 IF MASK_INT=0 THEN GOTO 6665			
06630 LET APP_MASK$="-"+MASKERA$(16-MASK_INT); IF MASK_DEC<>0 THEN LET APP_MASK$=APP_MASK$+"."+FILL(MASK_DEC,"0")			
06635 LET MASK_NUM=NUM(GDAT$[ROW,COL])			
06640 IF MASK_NUM=0 AND LEN(CVS(GDAT$[ROW,1],3))=0 THEN GOTO 6660			
06645 LET GRID_C.BUF$=TBL(STR(MASK_NUM:APP_MASK$),TBL=L65)			
06650 IF GCPS$[COL](1,1)="3" THEN LET GRID_C.BUF$=GRID_C.BUF$+"%"			
06655 LET GRID_C.STYLE=0			
06660 GOTO 6700			
06665 REM --------------------------------------------------------			
06670 LET GRID_C.BUF$=GDAT$[ROW,COL]			
06675 IF LEN(ECHO_LB_TMP$[COL])=0 THEN GOTO 6690			
06680 LET APP=POS(GRID_C.BUF$=ECHO_LB_TMP$[COL]); IF APP=0 THEN GOTO 6690			
06685 LET GRID_C.BUF$=ECHO_LB_TMP$[COL](APP,POS($0A$=ECHO_LB_TMP$[COL](APP)))			
06690 REM --------------------------------------------------------			
06695 LET GRID_C.STYLE=NUM(GCPS$[COL](2,2))			
06700 REM --------------------------------------------------------			
06705 LET GRID_C.ALIGNMENT=NUM(GCPS$[COL](1,1))			
06710 IF GCPS$[COL](1,1)="3" THEN LET GRID_C.ALIGNMENT=1			
06715 IF GRID_C.STYLE=91 THEN LET GRID_C.STYLE=0; IF LEN(CVS(GRID_C.BUF$,3))=8 THEN LET GRID_C.BUF$=FND10$(GRID_C.BUF$); GOTO 6735			
06720 IF GRID_C.STYLE=8 AND GDAT$[ROW,COL]="Y" THEN LET GRID_C.STYLE=4,GRID_C.BUF$=""; GOTO 6735			
06725 IF GRID_C.STYLE=8 AND GDAT$[ROW,COL]<>"Y" THEN LET GRID_C.BUF$=""; GOTO 6735			
06730 LET GRID_C.IMGIDX=999; IF IMG_IDX<>0 THEN LET GRID_C.IMGIDX=IMG_IDX-1			
06735 LET GRID_MT$[ROW,COL]=GRID_C$			
06740 LET GDAT$[ROW,COL]=IMG_BUF$			
06745 NEXT COL			
06750 LABEL_NEXT_ROW: 			
06755 NEXT ROW			
06760 GOTO USCITA			
06765 REM --------------------------------------------------------------------			
06770 SUB_V2_SHOWGRD: 			
06775 SETESC SUBESC; SETERR SUBERR			
06780 ENTER SYSGUI,ACT_CTX,GRID_ID,TOT_ROW,GRID_MT$[ALL]			
06785 IF GRID_ID=0 THEN GOTO USCITA; 	REM activation-		
06790 LET GRID_SORT$=STBL("grid_sort")			
06795 IF NUM(GRID_SORT$(1,5))=GRID_ID THEN GOTO 6815			
06800 REM ....Reset stbl GridId/Indice/Direzione         ..........-			
06805 LET APP$=STR(GRID_ID:"00000")+STR(0:"000")+" "			
06810 LET APP$=STBL("grid_sort",APP$)			
06815 PRINT (SYSGUI)'CONTEXT'(ACT_CTX),			
06820 GOSUB GET_GRID_INFORMATION			
06825 GOSUB SUB_LOAD_CUSTOM_UTENTE			
06830 DIM GRID_C$:TMPL(SYSGUI,IND=1)			
06835 LET APP$=SENDMSG(SYSGUI,GRID_ID,67,MAX(TOT_ROW,ROW_VIS),$$); 	REM nr row-		
06840 FOR ROW=ROW_TOP TO ROW_TOP+ROW_VIS+1			
06845 LET APP_DAT$=""; FOR COL=1 TO TOT_COL; LET APP_DAT$=APP_DAT$+CVS(GRID_MT$[ROW,COL],3); NEXT COL; IF LEN(APP_DAT$)=0 THEN GOTO LABEL_V2_NEXT_ROW			
06850 FOR COL=1 TO TOT_COL			
06855 LET GRID_C$=GRID_MT$[ROW,COL]			
06860 LET RESULT$=SENDMSG(SYSGUI,GRID_ID,54,0,GRID_C$)			
06865 NEXT COL			
06870 LABEL_V2_NEXT_ROW: 			
06875 NEXT ROW			
06880 GOTO USCITA			
06885 REM ----------------------------------------------------------------			
06890 SUB_SETROW: 			
06895 SETESC SUBESC; SETERR SUBERR			
06900 ENTER SYSGUI,ACT_CTX,GRID_ID,TOT_ROW,GRID_MT$[ALL],TO_FIND$,ROW_IN			
06905 PRINT (SYSGUI)'CONTEXT'(ACT_CTX),			
06910 GOSUB GET_GRID_INFORMATION			
06915 GOSUB SUB_LOAD_CUSTOM_UTENTE			
06920 LET ROW_FIND=0			
06925 LET ROW_IN=MAX(ROW_IN,1)			
06930 FOR ROW=ROW_IN TO TOT_ROW			
06935 FOR COL=1 TO TOT_COL			
06940 IF POS(CVS(TO_FIND$,39)=CVS(GRID_MT$[ROW,COL],39))>0 THEN LET ROW_FIND=ROW; EXITTO 6955			
06945 NEXT COL			
06950 NEXT ROW			
06955 SWITCH SGN(ROW_FIND)			
06960 CASE 0; BREAK			
06965 CASE 1; LET ROW$=SENDMSG(SYSGUI,GRID_ID,48,ROW_FIND-1,$$); BREAK			
06970 SWEND			
06975 GOTO USCITA			
06980 REM ----------------------------------------------------------------			
06985 SUB_SET_Y_ROW: 			
06990 SETESC SUBESC; SETERR SUBERR			
06995 ENTER SYSGUI,ACT_CTX,GRID_ID,T_ROW,TIPO			
07000 REM tipo = 0 : prima riga-			
07005 REM tipo = 1 : ultima riga-			
07010 REM tipo = 2 : riga indicata in t_row-			
07015 PRINT (SYSGUI)'CONTEXT'(ACT_CTX),			
07020 GOSUB GET_GRID_INFORMATION			
07025 GOSUB SUB_LOAD_CUSTOM_UTENTE			
07030 SWITCH TIPO			
07035 CASE 0; LET ROW$=SENDMSG(SYSGUI,GRID_ID,48,0,$$); BREAK			
07040 CASE 1; LET ROW$=SENDMSG(SYSGUI,GRID_ID,48,T_ROW-1,$$); BREAK			
07045 CASE 2; LET ROW$=SENDMSG(SYSGUI,GRID_ID,48,MAX(T_ROW-1,0),$$); BREAK			
07050 SWEND			
07055 GOTO USCITA			
07060 REM =====================================================================-			
07065 SUB_SET_HEADER_ROW: 			
07070 SETESC SUBESC; SETERR SUBERR			
07075 ENTER SYSGUI,ACT_CTX,GRID_ID,TOT_ROW,GCHD$[ALL]			
07080 PRINT (SYSGUI)'CONTEXT'(ACT_CTX),			
07085 GOSUB SUB_LOAD_CUSTOM_UTENTE			
07090 DIM GRID_C$:TMPL(SYSGUI,IND=1)			
07095 FOR ROW=0 TO TOT_ROW-1			
07100 LET GRID_C.COL%=0			
07105 LET GRID_C.ROW%=ROW			
07110 IF GCHD$[ROW+1]="" THEN LET GCHD$[ROW+1]="Row"+STR(ROW+1)			
07115 LET GRID_C.TEXTCOLOR$=$00FF00$			
07120 LET GRID_C.BACKCOLOR$='RGB'($12$)			
07125 LET GRID_C.BUF$=GCHD$[ROW+1]			
07130 LET GRID_C.ALIGNMENT=0			
07135 LET GRID_C.STYLE=2			
07140 LET RESULT$=SENDMSG(SYSGUI,GRID_ID+2,54,0,GRID_C$)			
07145 NEXT ROW			
07150 EXIT 			
07155 REM =====================================================================-			
07160 SET_HEADER_COL: 			
07165 SETESC SUBESC; SETERR SUBERR			
07170 ENTER SYSGUI,ACT_CTX,GRID_ID,TOT_COL,GCHD$[ALL]			
07175 PRINT (SYSGUI)'CONTEXT'(ACT_CTX),			
07180 GOSUB SUB_LOAD_CUSTOM_UTENTE			
07185 DIM GRID_C$:TMPL(SYSGUI,IND=1)			
07190 GOSUB SUB_SET_HEADER_COL			
07195 EXIT 			
07200 REM -------------------------------------------------------			
07205 REM -------------------------------------------------------			
07210 SUB_GRID_UTILITY: 			
07215 SETESC SUBESC; SETERR SUBERR			
07220 ENTER SYSGUI,ACT_CTX,GRID_ID,T_COL,T_ROW,GDAT$[ALL],GCHD$[ALL],GCPS$[ALL]			
07225 IF GRID_ID=0 THEN GOTO USCITA; 	REM activation-		
07230 L65: TABLE FF 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2E 2D 2C 2F 			
07235 PRINT (SYSGUI)'CONTEXT'(ACT_CTX),			
07240 GOSUB GET_GRID_INFORMATION			
07245 GOSUB SUB_LOAD_CUSTOM_UTENTE			
07250 LET GB__SYSGUI=UNT; OPEN (GB__SYSGUI)"X0"; LET REPORT_OPEN=1			
07255 DIM GB__SYSGUI_FIN$:TMPL(GB__SYSGUI,IND=0)			
07260 DIM GB__EVENT$:TMPL(GB__SYSGUI)			
07265 LET GB__EVENT=LEN(GB__EVENT$)			
07270 REM ..Scale.............................................................. -			
07275 LET GB__SYSGUI_FIN$=FIN(GB__SYSGUI)			
07280 LET PS_SCALE_X=GB__SYSGUI_FIN.SCREEN_WIDTH/800			
07285 LET PS_SCALE_Y=GB__SYSGUI_FIN.SCREEN_HEIGHT/600			
07290 PRINT (GB__SYSGUI)'SCALE'(PS_SCALE_X,PS_SCALE_Y),			
07295 REM ..................................................................... -			
07300 PRINT 'HIDE'(0),			
07305 LET GB__HANDLE=RESOPEN("rbgmgd.brc")			
07310 LET GB__SYSGUI_FIN$=FIN(GB__SYSGUI)			
07315 LET GB__FORM_CONTEXT=GB__SYSGUI_FIN.AVAILABLE_CONTEXT			
07320 LET GB__RESOURCE$=RESGET(GB__HANDLE,1,101)			
07325 PRINT (GB__SYSGUI)'CONTEXT'(GB__FORM_CONTEXT),'RESOURCE'(LEN(GB__RESOURCE$)),GB__RESOURCE$,'FLUSH',; 	REM il flush elimina l'ultimo evento legato alla form del programma chiamante-		
07330 RESCLOSE (GB__HANDLE)			
07335 REM ......verifica se load da file....................................... -			
07340 LET FILENM$=GDAT$[1,1]			
07345 IF POS("ImportFile:"=FILENM$)=1 THEN LET FILENM$=FILENM$(12); GOSUB SUB_GU_IMPORT_FILE; IF T_COL=0 THEN GOTO GRID_UTILITY_END FI; CLOSE (GU_TXT); 	REM ctl esistenza+set col+set env-		
07350 REM ......................................................................-			
07355 GOSUB SUB_GU_SET_RIGA_ENV			
07360 GOSUB SUB_GU_SHOW_DATI_INIT			
07365 GOSUB SUB_GU_SHOW_RIGA			
07370 GOSUB SUB_UTILITY_GU_LOAD_LB			
07375 GOSUB SUB_UTILITY_TOT_COL; GOSUB SUB_UTILITY_TOT_COL_PRINT			
07380 GB__EVENT: 			
07385 READ RECORD(GB__SYSGUI,SIZ=GB__EVENT,ERR=GRID_UTILITY_END)GB__EVENT$			
07390 REM  IF GB__EVENT.CONTEXT<>GB__FORM_CONTEXT THEN GOTO GRID_UTILITY_END-			
07395 IF GB__EVENT.ID=707 THEN GOTO GRID_UTILITY_END			
07400 IF GB__EVENT.ID=1020 THEN GOSUB SUB_COPY_CLIPBOARD			
07405 IF GB__EVENT.ID=1030 THEN GOSUB SUB_STAMPA_BROGLIACCIO			
07410 IF GB__EVENT.ID=1050 THEN LET ROW_SEL=1; PRINT (GB__SYSGUI)'TITLE'(1503,STR(ROW_SEL)); GOSUB SUB_GU_SHOW_RIGA			
07415 IF GB__EVENT.ID=1060 THEN LET ROW_SEL=T_ROW; PRINT (GB__SYSGUI)'TITLE'(1503,STR(ROW_SEL)); GOSUB SUB_GU_SHOW_RIGA			
07420 IF GB__EVENT.ID=1070 THEN GOSUB SUB_UTILITY_COL_UP			
07425 IF GB__EVENT.ID=1080 THEN GOSUB SUB_UTILITY_COL_DW			
07430 IF GB__EVENT.ID=1090 THEN GOSUB SUB_COPY_CLIPBOARD_PIVOT			
07435 IF GB__EVENT.ID=1220 THEN GOSUB SUB_UTILITY_PIVOT; GOSUB SUB_UTILITY_GU_PIVOT_SHOW; GOSUB SUB_SET_RESIZE			
07440 IF GB__EVENT.ID=1201 THEN GOSUB SUB_GU_SET_RIGA_ENV; GOSUB SUB_GU_SHOW_RIGA			
07445 IF GB__EVENT.ID=1202 THEN GOSUB SUB_GU_SET_PIVOT_ENV			
07450 IF GB__EVENT.ID=3001 AND GB__EVENT.CODE$="N" AND GB__EVENT.FLAGS=22 AND CTRL(GB__SYSGUI,1201,2)=$01$ THEN GOSUB SUB_UTILITY_GU_RIGA_SHOW			
07455 IF GB__EVENT.ID=3001 AND GB__EVENT.CODE$="N" AND GB__EVENT.FLAGS=22 AND CTRL(GB__SYSGUI,1202,2)=$01$ THEN GOSUB SUB_UTILITY_GU_PIVOT_SHOW			
07460 IF GB__EVENT.ID=3001 AND GB__EVENT.CODE$="N" AND GB__EVENT.FLAGS=14 AND CTRL(GB__SYSGUI,1202,2)=$01$ THEN GOSUB SUB_UTILITY_GU_PIVOT_COL_STAT			
07465 GOTO GB__EVENT			
07470 GRID_UTILITY_END: 			
07475 PRINT (GB__SYSGUI)'DESTROY'(0)			
07480 CLOSE (GB__SYSGUI)			
07485 PRINT (SYSGUI)'CONTEXT'(ACT_CTX),			
07490 EXIT 			
07495 GB__NOTICE: 			
07500 LET GB__GENERIC$=NOTICE(GB__SYSGUI,GB__EVENT.X%)			
07505 DIM GB__NOTICE$:NOTICETPL(GB__GENERIC.OBJTYPE%,GB__EVENT.FLAGS%)			
07510 LET GB__NOTICE$=GB__GENERIC$			
07515 RETURN 			
07520 SUB_COPY_CLIPBOARD_PIVOT: 			
07525 LET APP=LEN(REPORT_PIVOT$)/GU_STEP			
07530 CALL "rbgexp::sub_clip","","",0,APP,GU_COL,GU_DAT$[ALL],GU_HD$[ALL],GU_PS$[ALL]			
07535 RETURN 			
07540 CALL "rbgmgd::sub_showgrd",GB__SYSGUI,GB__FORM_CONTEXT,GU_ID,GU_ROW,GU_DAT$[ALL],GU_PS$[ALL]			
07545 SUB_COPY_CLIPBOARD: 			
07550 CALL "rbgexp::sub_clip","","",0,T_ROW,T_COL,GDAT$[ALL],GCHD$[ALL],GCPS$[ALL]			
07555 RETURN 			
07560 SUB_STAMPA_BROGLIACCIO: 			
07565 CALL "rbgexp::sub_stampa","","",0,T_ROW,T_COL,GDAT$[ALL],GCHD$[ALL],GCPS$[ALL]			
07570 RETURN 			
07575 SUB_GU_SET_PIVOT: 			
07580 PRINT (GB__SYSGUI)'UNCHECK'(1201),'ENABLE'(1211,1212,1213,1219,1220)			
07585 RETURN 			
07590 REM =================================================================-			
07595 SUB_UTILITY_TOT_COL: 			
07600 LET UTILITY_POS=0,UTILITY_MIN=0,UTILITY_MAX=0			
07605 LET UTILITY_TOT=0,UTILITY_INC=0,UTILITY_MED=0			
07610 LET UTILITY_MEDX=0,UTILITY_MEDN=0			
07615 LET ERR_NRC$=GDAT$[ROW_SEL,COL_SEL]; FOR X=1 TO LEN(ERR_NRC$); IF POS(ERR_NRC$(X,1)="0123456789,")=0 THEN LET ERR_NRC=1 FI; NEXT X; IF ERR_NRC=1 THEN GOTO 7665			
07620 LET UTILITY_VAL=NUM(GDAT$[ROW_SEL,COL_SEL])			
07625 LET APP$=""			
07630 FOR APP=1 TO T_ROW			
07635 LET ERR_NRC$=GDAT$[APP,COL_SEL]; FOR X=1 TO LEN(ERR_NRC$); IF POS(ERR_NRC$(X,1)="0123456789,")=0 THEN LET ERR_NRC=1 FI; NEXT X; IF ERR_NRC=1 THEN EXITTO 7665			
07640 LET UTILITY_TOT=UTILITY_TOT+NUM(GDAT$[APP,COL_SEL])			
07645 IF NUM(GDAT$[APP,COL_SEL])<UTILITY_VAL THEN LET UTILITY_MIN=UTILITY_MIN+1			
07650 IF NUM(GDAT$[APP,COL_SEL])>UTILITY_VAL THEN LET UTILITY_MAX=UTILITY_MAX+1			
07655 LET APP$=APP$+STR(NUM(GDAT$[APP,COL_SEL]):"000000000000000000")+"R"+STR(APP:"00000")			
07660 NEXT APP			
07665 REM ....-			
07670 IF ERR_NRC=1 THEN LET UTILITY_TOT=0,UTILITY_MIN=0,UTILITY_MAX=0; RETURN 			
07675 LET APP$=SSORT(APP$,24)			
07680 LET APP=POS("R"+STR(ROW_SEL:"00000")=APP$)			
07685 LET UTILITY_POS=(APP+5)/24			
07690 LET UTILITY_MED=UTILITY_TOT/T_ROW			
07695 LET UTILITY_INC=(UTILITY_VAL)/(UTILITY_TOT/100)			
07700 FOR APP=1 TO T_ROW			
07705 IF NUM(GDAT$[APP,COL_SEL])<UTILITY_MED THEN LET UTILITY_MEDN=UTILITY_MEDN+1			
07710 IF NUM(GDAT$[APP,COL_SEL])>UTILITY_MED THEN LET UTILITY_MEDX=UTILITY_MEDX+1			
07715 NEXT APP			
07720 RETURN 			
07725 SUB_UTILITY_TOT_COL_PRINT: 			
07730 PRINT (GB__SYSGUI)'TITLE'(1506,TBL(STR(UTILITY_MAX:"###,##0"),TBL=L65)),'TITLE'(1507,TBL(STR(UTILITY_MIN:"###,##0"),TBL=L65)),'TITLE'(1508,STR(UTILITY_POS:"###,###,##0.00")),'TITLE'(1510,TBL(STR(UTILITY_TOT:"###,###,##0.00"),TBL=L65)),'TITLE'(1511,TBL(STR(UTILITY_MED:"###,###,##0.00"),TBL=L65)),'TITLE'(1512,TBL(STR(UTILITY_MEDX:"###,##0"),TBL=L65)),'TITLE'(1513,TBL(STR(UTILITY_MEDN:"###,##0"),TBL=L65)),'TITLE'(1509,STR(UTILITY_INC:"#,##0.00"))			
07735 RETURN 			
07740 REM =========================================================riga /*start-			
07745 SUB_UTILITY_GU_LOAD_LB: 			
07750 LET LABEL$="00-(nessuno)"+$0A$			
07755 FOR GU_R=1 TO LEN(COL_SEQ$) STEP 3; LET APP=NUM(COL_SEQ$(GU_R,3)),LABEL$=LABEL$+STR(APP:"00-")+GCHD$[APP]+$0A$; NEXT GU_R			
07760 PRINT (GB__SYSGUI)'LISTCLR'(1209),'LISTADD'(1209,0,POS($0A$=LABEL$,1,0)),LABEL$,'LISTRESUME'(1209),'LISTSEL'(1209,0),			
07765 PRINT (GB__SYSGUI)'LISTCLR'(1211),'LISTADD'(1211,0,POS($0A$=LABEL$,1,0)),LABEL$,'LISTRESUME'(1211),'LISTSEL'(1211,0),			
07770 PRINT (GB__SYSGUI)'LISTCLR'(1212),'LISTADD'(1212,0,POS($0A$=LABEL$,1,0)),LABEL$,'LISTRESUME'(1212),'LISTSEL'(1212,0),			
07775 PRINT (GB__SYSGUI)'LISTCLR'(1213),'LISTADD'(1213,0,POS($0A$=LABEL$,1,0)),LABEL$,'LISTRESUME'(1212),'LISTSEL'(1213,0),			
07780 PRINT (GB__SYSGUI)'LISTCLR'(1218),'LISTADD'(1218,0,POS($0A$=LABEL$,1,0)),LABEL$,'LISTRESUME'(1218),'LISTSEL'(1218,0),			
07785 PRINT (GB__SYSGUI)'LISTCLR'(1219),'LISTADD'(1219,0,POS($0A$=LABEL$,1,0)),LABEL$,'LISTRESUME'(1219),'LISTSEL'(1219,0),			
07790 RETURN 			
07795 REM ========================================================pivot /*start-			
07800 SUB_UTILITY_PIVOT: 			
07805 LET PIVOT_DATE_IN$=DATE(0:"%Y%Mz%Dz%Hz%mz%sz")			
07810 LET PIVOT_R=3000,PIVOT_C=50; 	REM max numero di righe/colonne-		
07815 SETERR 7820; DIM GU_PIVOT[PIVOT_R,PIVOT_C]; LET REPORT_PIVOT$="",REPORT_PIVOTX$="",GU_STEP=0; GOTO 7830			
07820 LET X=MSGBOX("Memoria non sufficiente per eseguire l'operazione",48,"")			
07825 LET GU_ROW=0; RETURN 			
07830 SETERR SUBERR			
07835 LET APP$=CTRL(GB__SYSGUI,1210,1); LET GU_NUM$=APP$(1,1)			
07840 LET APP$=CTRL(GB__SYSGUI,1211,1); LET GU_CPO1=NUM(APP$(1,2)); 	REM row-		
07845 LET APP$=CTRL(GB__SYSGUI,1212,1); LET GU_CPO2=NUM(APP$(1,2)); 	REM row-		
07850 LET APP$=CTRL(GB__SYSGUI,1213,1); LET GU_CPO3=NUM(APP$(1,2)); 	REM row-		
07855 LET APP$=CTRL(GB__SYSGUI,1218,1); LET GU_CPO8=NUM(APP$(1,2)); 	REM col-		
07860 LET APP$=CTRL(GB__SYSGUI,1219,1); LET GU_CPO9=NUM(APP$(1,2)); 	REM data-		
07865 IF GU_CPO1=0 OR GU_CPO9=0 THEN RETURN 			
07870 IF GU_IF=1 THEN GOSUB SUB_GU_IMPORT_FILE			
07875 FOR GU_R=1 TO T_ROW			
07880 SWITCH GU_IF			
07885 CASE 0; 	REM normale-		
07890 CASE 2; 	REM da file con poche colonne - caricato una sola volta-		
07895 PRINT (GB__SYSGUI)'TITLE'(1551,"Calcolo:"+STR(GU_R/(T_ROW/100)))			
07900 BREAK			
07905 CASE 1; 	REM da file con molte colonne - caricato una riga per volta-		
07910 GOSUB SUB_GU_IMPORT_FILE_READ			
07915 LET GU_R=1			
07920 BREAK			
07925 SWEND			
07930 IF GU_READ_END=1 THEN EXITTO 8060			
07935 REM ----se import da file una riga per volta---------------/*end   -			
07940 LET APP$=GDAT$[GU_R,GU_CPO1],APP=POS(" "=APP$); IF APP>1 THEN LET APP$=APP$(1,APP-1) FI; IF GCPS$[GU_CPO1](1,1)="1" THEN LET GU_PADP$="R",GU_PADC$=" " ELSE LET GU_PADP$="L",GU_PADC$=" " FI; LET GU_GROUP$=PAD(APP$,250,GU_PADP$,GU_PADC$)			
07945 IF GU_CPO2 THEN LET APP$=GDAT$[GU_R,GU_CPO2],APP=POS(" "=APP$); IF APP>1 THEN LET APP$=APP$(1,APP-1) FI; IF GCPS$[GU_CPO2](1,1)="1" THEN LET GU_PADP$="R",GU_PADC$=" " ELSE LET GU_PADP$="L",GU_PADC$=" " FI; LET GU_GROUP$=GU_GROUP$+PAD(APP$,250,GU_PADP$,GU_PADC$)			
07950 IF GU_CPO3 THEN LET APP$=GDAT$[GU_R,GU_CPO3],APP=POS(" "=APP$); IF APP>1 THEN LET APP$=APP$(1,APP-1) FI; IF GCPS$[GU_CPO3](1,1)="1" THEN LET GU_PADP$="R",GU_PADC$=" " ELSE LET GU_PADP$="L",GU_PADC$=" " FI; LET GU_GROUP$=GU_GROUP$+PAD(APP$,250,GU_PADP$,GU_PADC$)			
07955 LET GU_STEP=LEN(GU_GROUP$)			
07960 LET APP=POS(GU_GROUP$=REPORT_PIVOT$,GU_STEP,1)			
07965 IF APP=0 THEN LET APP=LEN(REPORT_PIVOT$)+1,REPORT_PIVOT$=REPORT_PIVOT$+GU_GROUP$			
07970 LET GU_ELE=(APP+(GU_STEP-1))/GU_STEP			
07975 IF GU_ELE>PIVOT_R THEN LET X=MSGBOX("Troppe righe di pivot. Max "+STR(PIVOT_R),48,""); LET GU_ROW=0; EXITTO 8065			
07980 REM ---------------------------------------------------------------			
07985 SWITCH SGN(GU_CPO8)			
07990 CASE 0; LET APP$="[All]"; BREAK			
07995 CASE 1; LET APP$=GDAT$[GU_R,GU_CPO8],APP=POS(" "=APP$); IF APP>1 THEN LET APP$=APP$(1,APP-1) FI; BREAK			
08000 SWEND			
08005 LET GU_GROUPX$=PAD(APP$,250,"R"," ")			
08010 LET APP=POS(GU_GROUPX$=REPORT_PIVOTX$,250,1)			
08015 IF APP=0 THEN LET APP=LEN(REPORT_PIVOTX$)+1,REPORT_PIVOTX$=REPORT_PIVOTX$+GU_GROUPX$			
08020 LET GU_ELEX=(APP+249)/250			
08025 IF GU_ELEX>PIVOT_C THEN LET X=MSGBOX("Troppe colonne di pivot. Max "+STR(PIVOT_C),48,""); LET GU_ROW=0; EXITTO 8065			
08030 REM ---------------------------------------------------------------			
08035 SWITCH GU_NUM$="C"			
08040 CASE 0; LET APP$=GDAT$[GU_R,GU_CPO9]; GOSUB SUB_LEVA_VIRGOLA; LET GU_PIVOT[GU_ELE,GU_ELEX]=GU_PIVOT[GU_ELE,GU_ELEX]+NUM(APP$); BREAK; 	REM NUM(GDAT$[GU_R,GU_CPO9]); BREAK-		
08045 CASE 1; LET GU_PIVOT[GU_ELE,GU_ELEX]=GU_PIVOT[GU_ELE,GU_ELEX]+1; BREAK			
08050 SWEND			
08055 NEXT GU_R			
08060 REM ---			
08065 IF GU_ROW=0 THEN RETURN ; 	REM errore-		
08070 IF GU_IF=1 THEN LET T_ROW=GU_IMPORT; CLOSE (GU_TXT); 	REM righe lette-		
08075 REM SORT NO :ssort funziona fino a step max di 128 chr/*start<-------------			
08080 REM          (qui invece la somma dei 3 campi e' 250 o 500 o 750 chr )-			
08085 REM          (non posso quindi neanche creare un file )-			
08090 REM          o scrivo una subroutine o limito-			
08095 REM          Quindi..... bubble sort!!-			
08100 LET ORG_REPORT_PIVOT$=REPORT_PIVOT$,ORG_REPORT_PIVOTX$=REPORT_PIVOTX$			
08105 LET ORG_GU_PIVOT[ALL]=GU_PIVOT[ALL]			
08110 IF LEN(REPORT_PIVOT$)=GU_STEP THEN GOTO 8200; 	REM un solo elemento/sort not need-		
08115 REM ..bubble sort, ma ancora più semplice (sempre intero range)    Y-			
08120 FOR GU_BUBBLE=1 TO LEN(REPORT_PIVOT$) STEP GU_STEP			
08125 PRINT (GB__SYSGUI)'TITLE'(1551,"Sort1:"+STR(GU_BUBBLE/((LEN(REPORT_PIVOT$)/GU_STEP)/100)))			
08130 FOR GU_ELE=1 TO LEN(REPORT_PIVOT$)-GU_STEP STEP GU_STEP			
08135 LET AP1=GU_ELE,AP2=AP1+GU_STEP			
08140 IF REPORT_PIVOT$(AP1,GU_STEP)>REPORT_PIVOT$(AP2,GU_STEP) THEN LET APP$=REPORT_PIVOT$(AP1,GU_STEP),REPORT_PIVOT$(AP1,GU_STEP)=REPORT_PIVOT$(AP2,GU_STEP),REPORT_PIVOT$(AP2,GU_STEP)=APP$			
08145 NEXT GU_ELE			
08150 NEXT GU_BUBBLE			
08155 REM ..bubble sort, ma ancora più semplice (sempre intero range)    X-			
08160 IF LEN(REPORT_PIVOTX$)=250 THEN GOTO 8200; 	REM una sola colonna-		
08165 FOR GU_BUBBLE=1 TO LEN(REPORT_PIVOTX$) STEP 250			
08170 PRINT (GB__SYSGUI)'TITLE'(1551,"Sort2:"+STR(GU_BUBBLE/((LEN(REPORT_PIVOTX$)/250)/100)))			
08175 FOR GU_ELE=1 TO LEN(REPORT_PIVOTX$)-250 STEP 250			
08180 LET AP1=GU_ELE,AP2=AP1+250			
08185 IF REPORT_PIVOTX$(AP1,250)>REPORT_PIVOTX$(AP2,250) THEN LET APP$=REPORT_PIVOTX$(AP1,250),REPORT_PIVOTX$(AP1,250)=REPORT_PIVOTX$(AP2,250),REPORT_PIVOTX$(AP2,250)=APP$			
08190 NEXT GU_ELE			
08195 NEXT GU_BUBBLE			
08200 REM ..........-			
08205 FOR GU_ELEY=1 TO LEN(REPORT_PIVOT$) STEP GU_STEP			
08210 FOR GU_ELEX=1 TO LEN(REPORT_PIVOTX$) STEP 250			
08215 LET ED_Y=(GU_ELEY+(GU_STEP-1))/GU_STEP			
08220 LET ED_X=(GU_ELEX+249)/250			
08225 LET EO_Y=(POS(REPORT_PIVOT$(GU_ELEY,GU_STEP)=ORG_REPORT_PIVOT$,GU_STEP,1)+GU_STEP-1)/GU_STEP			
08230 LET EO_X=(POS(REPORT_PIVOTX$(GU_ELEX,250)=ORG_REPORT_PIVOTX$,250,1)+249)/250			
08235 LET GU_PIVOT[ED_Y,ED_X]=ORG_GU_PIVOT[EO_Y,EO_X]			
08240 NEXT GU_ELEX			
08245 NEXT GU_ELEY			
08250 REM SORT NO :ssort funziona fino a step di 128 chr/*end  <-----------------			
08255 REM -----------INIT-			
08260 LET GU_ID=3001			
08265 LET GU_ROW=MAX(LEN(REPORT_PIVOT$)/GU_STEP,40)			
08270 LET GU_COLX=LEN(REPORT_PIVOTX$)/250			
08275 SWITCH GU_STEP			
08280 CASE 250			
08285 LET GU_COL=1+GU_COLX			
08290 DIM GU_DAT$[GU_ROW,GU_COL],GU_HD$[GU_COL],GU_PS$[GU_COL]			
08295 LET GU_HD$[1]=GCHD$[GU_CPO1]			
08300 LET GU_PS$[1]=GCPS$[GU_CPO1]			
08305 FOR APP=1 TO GU_COLX; LET GU_HD$[1+APP]=CVS(REPORT_PIVOTX$(APP*250-249,250),35); NEXT APP			
08310 FOR APP=1 TO GU_COLX; LET GU_PS$[1+APP]="192"; NEXT APP			
08315 BREAK			
08320 CASE 500			
08325 LET GU_COL=2+GU_COLX			
08330 DIM GU_DAT$[GU_ROW,GU_COL],GU_HD$[GU_COL],GU_PS$[GU_COL]			
08335 LET GU_HD$[1]=GCHD$[GU_CPO1],GU_HD$[2]=GCHD$[GU_CPO2]			
08340 LET GU_PS$[1]=GCPS$[GU_CPO1],GU_PS$[2]=GCPS$[GU_CPO2]			
08345 FOR APP=1 TO GU_COLX; LET GU_HD$[2+APP]=CVS(REPORT_PIVOTX$(APP*250-249,250),35); NEXT APP			
08350 FOR APP=1 TO GU_COLX; LET GU_PS$[2+APP]="192"; NEXT APP			
08355 BREAK			
08360 CASE 750			
08365 LET GU_COL=3+GU_COLX			
08370 DIM GU_DAT$[GU_ROW,GU_COL],GU_HD$[GU_COL],GU_PS$[GU_COL]			
08375 LET GU_HD$[1]=GCHD$[GU_CPO1],GU_HD$[2]=GCHD$[GU_CPO2],GU_HD$[3]=GCHD$[GU_CPO3]			
08380 LET GU_PS$[1]=GCPS$[GU_CPO1],GU_PS$[2]=GCPS$[GU_CPO2],GU_PS$[3]=GCPS$[GU_CPO3]			
08385 FOR APP=1 TO GU_COLX; LET GU_HD$[3+APP]=CVS(REPORT_PIVOTX$(APP*250-249,250),35); NEXT APP			
08390 FOR APP=1 TO GU_COLX; LET GU_PS$[3+APP]="192"; NEXT APP			
08395 BREAK			
08400 SWEND			
08405 GOSUB SUB_GU_SET_HEADER			
08410 SWITCH SGN(GU_ROW)			
08415 CASE 0; BREAK			
08420 CASE 1			
08425 REM -----------LOAD-			
08430 FOR GU_ELE=1 TO LEN(REPORT_PIVOT$)/GU_STEP			
08435 LET AP1=GU_ELE*GU_STEP-(GU_STEP-1)			
08440 SWITCH GU_STEP			
08445 CASE 250			
08450 LET GU_DAT$[GU_ELE,1]=CVS(REPORT_PIVOT$(AP1,GU_STEP),3)			
08455 FOR APP=1 TO GU_COLX; IF GU_PIVOT[GU_ELE,APP]<>0 THEN LET GU_DAT$[GU_ELE,1+APP]=STR(GU_PIVOT[GU_ELE,APP]) FI; NEXT APP			
08460 BREAK			
08465 CASE 500			
08470 LET GU_DAT$[GU_ELE,1]=CVS(REPORT_PIVOT$(AP1,250),3)			
08475 LET GU_DAT$[GU_ELE,2]=CVS(REPORT_PIVOT$(AP1+250,250),3)			
08480 FOR APP=1 TO GU_COLX; IF GU_PIVOT[GU_ELE,APP]<>0 THEN LET GU_DAT$[GU_ELE,2+APP]=STR(GU_PIVOT[GU_ELE,APP]) FI; NEXT APP			
08485 BREAK			
08490 CASE 750			
08495 LET GU_DAT$[GU_ELE,1]=CVS(REPORT_PIVOT$(AP1,250),3)			
08500 LET GU_DAT$[GU_ELE,2]=CVS(REPORT_PIVOT$(AP1+250,250),3)			
08505 LET GU_DAT$[GU_ELE,3]=CVS(REPORT_PIVOT$(AP1+500,250),3)			
08510 FOR APP=1 TO GU_COLX; IF GU_PIVOT[GU_ELE,APP]<>0 THEN LET GU_DAT$[GU_ELE,3+APP]=STR(GU_PIVOT[GU_ELE,APP]) FI; NEXT APP			
08515 BREAK			
08520 SWEND			
08525 NEXT GU_ELE			
08530 BREAK			
08535 SWEND			
08540 LET PIVOT_DATE_FN$=DATE(0:"%Y%Mz%Dz%Hz%mz%sz")			
08545 CALL "rbadlt::SUB_DELTA_TEMPO",PIVOT_DATE_IN$+$09$+PIVOT_DATE_FN$,D_OUT$			
08550 PRINT (GB__SYSGUI)'TITLE'(1551,"Analisi di "+STR(T_ROW)+" elementi, raggruppati in "+STR(LEN(REPORT_PIVOT$)/GU_STEP)+" righe e "+STR(LEN(REPORT_PIVOTX$)/250)+" colonne,eseguito in "+D_OUT$+" secondi")			
08555 RETURN 			
08560 SUB_UTILITY_GU_PIVOT_SHOW: 			
08565 SWITCH SGN(GU_ROW)			
08570 CASE 0; BREAK			
08575 CASE 1			
08580 CALL "rbgmgd::sub_showgrd",GB__SYSGUI,GB__FORM_CONTEXT,GU_ID,GU_ROW,GU_DAT$[ALL],GU_PS$[ALL]			
08585 PRINT (GB__SYSGUI)'FLUSH',			
08590 BREAK			
08595 SWEND			
08600 RETURN 			
08605 SUB_UTILITY_GU_PIVOT_COL_STAT: 			
08610 LET COL$=SENDMSG(GB__SYSGUI,3001,44,0,$$),STAT_COL_SEL=DEC($00$+COL$)+1			
08615 LET STAT_TOT_0=0,STAT_TOT_1=0,STAT_TOT_VAL=0,ERR_NRC=0			
08620 FOR STAT_ROW=1 TO GU_ROW			
08625 LET ERR_NRC$=GU_DAT$[STAT_ROW,STAT_COL_SEL]; IF LEN(ERR_NRC$)=0 THEN GOTO 8645 ELSE FOR X=1 TO LEN(ERR_NRC$); IF POS(ERR_NRC$(X,1)="0123456789,")=0 THEN LET ERR_NRC=1 FI; NEXT X; IF ERR_NRC=1 THEN LET STAT_TOT_0=0,STAT_TOT_1=0; EXITTO 8650			
08630 IF NUM(GU_DAT$[STAT_ROW,STAT_COL_SEL])=0 THEN LET STAT_TOT_0=STAT_TOT_0+1			
08635 LET STAT_TOT_VAL=STAT_TOT_VAL+NUM(GU_DAT$[STAT_ROW,STAT_COL_SEL])			
08640 IF NUM(GU_DAT$[STAT_ROW,STAT_COL_SEL])<>0 THEN LET STAT_TOT_1=STAT_TOT_1+1			
08645 NEXT STAT_ROW			
08650 REM ...-			
08655 PRINT (GB__SYSGUI)'TITLE'(1551,"Somma valori colonna "+STR(STAT_TOT_VAL)+" - Elementi valorizzati "+STR(STAT_TOT_1)+" - Elementi non valorizzati "+STR(STAT_TOT_0))			
08660 RETURN 			
08665 REM ------------------------------------------------			
08670 REM --- Import file-			
08675 REM ---    Se t_col <=10 then gu_if=1;load gdat completamente-			
08680 REM ---    Se t_col > 10 then gu_if=2;load gdat una riga per volta-			
08685 REM ------------------------------------------------			
08690 SUB_GU_IMPORT_FILE: 			
08695 LET T_COL=0,T_ROW=100000,GU_IMPORT=0			
08700 LET GU_TXT=UNT; OPEN (GU_TXT)FILENM$			
08705 READ (GU_TXT,END=8815)TXT$; IF LEN(TXT$)=0 THEN GOTO 8705			
08710 LET GU_IMPORT=0			
08715 LET T_COL=POS($09$=TXT$,1,0)			
08720 DIM GU_REC_TXT$:"cpo["+STR(T_COL)+"]:c(500*=9)"			
08725 DIM GCHD$[T_COL],GCPS$[T_COL]			
08730 LET GU_REC_TXT$=TXT$+$09$			
08735 FOR APP=1 TO T_COL; LET GCHD$[APP]=GU_REC_TXT.CPO$[APP]; NEXT APP			
08740 FOR APP=1 TO T_COL; LET GCPS$[APP]="000"; NEXT APP			
08745 SWITCH SGN(T_COL-200)			
08750 CASE -1			
08755 CASE 0			
08760 LET GU_IF=2; 	REM load gdat completamente-		
08765 DIM GDAT$[20000,T_COL]			
08770 GOSUB SUB_GU_IMPORT_FILE_READ			
08775 IF GU_READ_END=0 THEN GOTO 8770			
08780 LET T_ROW=GU_IMPORT			
08785 BREAK			
08790 CASE 1			
08795 DIM GDAT$[1,T_COL]			
08800 LET GU_IF=1; 	REM una riga per volta-		
08805 BREAK			
08810 SWEND			
08815 REM ------			
08820 RETURN 			
08825 SUB_GU_IMPORT_FILE_READ: 			
08830 LET GU_READ_END=1			
08835 READ (GU_TXT,END=8920)TXT$; IF LEN(TXT$)=0 THEN GOTO 8835			
08840 LET GU_READ_END=0			
08845 LET GU_IMPORT=GU_IMPORT+1			
08850 PRINT (GB__SYSGUI)'TITLE'(1551,"Load :"+STR(GU_IMPORT))			
08855 LET GU_REC_TXT$=TXT$+$09$			
08860 SWITCH GU_IF			
08865 CASE 1			
08870 LET GDAT$[1,GU_CPO1]=GU_REC_TXT.CPO$[GU_CPO1]			
08875 IF GU_CPO2<>0 THEN LET GDAT$[1,GU_CPO2]=GU_REC_TXT.CPO$[GU_CPO2]			
08880 IF GU_CPO3<>0 THEN LET GDAT$[1,GU_CPO3]=GU_REC_TXT.CPO$[GU_CPO3]			
08885 IF GU_CPO8<>0 THEN LET GDAT$[1,GU_CPO8]=GU_REC_TXT.CPO$[GU_CPO8]			
08890 IF GU_CPO9<>0 THEN LET GDAT$[1,GU_CPO9]=GU_REC_TXT.CPO$[GU_CPO9]			
08895 BREAK			
08900 CASE 2			
08905 FOR APP=1 TO T_COL; LET GDAT$[GU_IMPORT,APP]=GU_REC_TXT.CPO$[APP]; NEXT APP			
08910 BREAK			
08915 SWEND			
08920 REM ----			
08925 RETURN 			
08930 SUB_LEVA_VIRGOLA: 			
08935 IF LEN(APP$)=0 THEN LET APP$=""; GOTO 8950			
08940 FOR APP=1 TO LEN(APP$); IF POS(APP$(APP,1)=" 0123456789,.-+")=0 THEN LET APP$=""; EXITTO 8950 FI; NEXT APP			
08945 LET APP=POS(","=APP$); IF APP>0 THEN LET APP$=APP$(1,APP-1)+APP$(APP+1); GOTO 8945			
08950 REM ..-			
08955 RETURN 			
08960 SUB_GU_SET_HEADER: 			
08965 DIM GRID_C$:TMPL(GB__SYSGUI,IND=1)			
08970 LET APP$=SENDMSG(GB__SYSGUI,GU_ID,67,0,$$); 	REM nr row       -		
08975 LET APP$=SENDMSG(GB__SYSGUI,GU_ID,66,GU_COL,$$); 	REM nr col -		
08980 LET APP$=SENDMSG(GB__SYSGUI,GU_ID,67,GU_ROW,$$); 	REM nr row -		
08985 FOR COL=0 TO GU_COL-1			
08990 LET GRID_C.COL%=COL,GRID_C.ROW%=0			
08995 LET GRID_C.TEXTCOLOR$=$00FF00$,GRID_C.BACKCOLOR$='RGB'($12$)			
09000 LET GRID_C.BUF$=GU_HD$[COL+1]			
09005 LET GRID_C.ALIGNMENT=0,GRID_C.STYLE=2			
09010 LET RESULT$=SENDMSG(GB__SYSGUI,GU_ID+1,54,0,GRID_C$)			
09015 NEXT COL			
09020 RETURN 			
09025 SUB_GU_SHOW_DATI_INIT: 			
09030 PRINT (GB__SYSGUI)'TITLE'(1500,STR(GRID_ID)),'TITLE'(1501,TBL(STR(T_ROW:"####0"),TBL=L65)),'TITLE'(1502,TBL(STR(T_COL:"####0"),TBL=L65)),'TITLE'(1514,STR(ROW_TOP)),'TITLE'(1515,STR(ROW_VIS)),			
09035 PRINT (GB__SYSGUI)'TITLE'(1503,TBL(STR(ROW_SEL:"####0"),TBL=L65)),'TITLE'(1504,TBL(STR(COL_SEL:"####0"),TBL=L65)),'TITLE'(1521,GCHD$[COL_SEL]),			
09040 RETURN 			
09045 SUB_GU_SET_RIGA_ENV: 			
09050 PRINT (GB__SYSGUI)'UNCHECK'(1202),'DISABLE'(1210,1211,1212,1213,1218,1219,1220),'ENABLE'(1209,1070,1080),			
09055 RETURN 			
09060 SUB_GU_SET_PIVOT_ENV: 			
09065 PRINT (GB__SYSGUI)'UNCHECK'(1201),'ENABLE'(1210,1211,1212,1213,1218,1219,1220),'DISABLE'(1209,1070,1080)			
09070 RETURN 			
09075 SUB_GU_SHOW_RIGA: 			
09080 LET ROW_SEL=MIN(NUM(SENDMSG(GB__SYSGUI,1503,20,0,$$)),T_ROW),ROW_SEL=MAX(ROW_SEL,1)			
09085 LET COL_SEL=MIN(NUM(SENDMSG(GB__SYSGUI,1504,20,0,$$)),T_COL),COL_SEL=MAX(COL_SEL,1)			
09090 PRINT (GB__SYSGUI)'TITLE'(1503,TBL(STR(ROW_SEL:"####0"),TBL=L65)),'TITLE'(1504,TBL(STR(COL_SEL:"####0"),TBL=L65))			
09095 PRINT (GB__SYSGUI)'TITLE'(1505,GDAT$[ROW_SEL,COL_SEL](1,MIN(250,LEN(GDAT$[ROW_SEL,COL_SEL]))))			
09100 REM -----------INIT-			
09105 LET GU_ROW=MAX(T_COL,40),GU_COL=2,GU_ID=3001			
09110 DIM GU_DAT$[GU_ROW,GU_COL],GU_HD$[GU_COL],GU_PS$[GU_COL]			
09115 LET GU_HD$[1]="Riga",GU_HD$[2]="Colonna"			
09120 LET GU_PS$[1]="000",GU_PS$[2]="000"			
09125 GOSUB SUB_GU_SET_HEADER			
09130 REM -----------LOAD-			
09135 FOR GU_R=1 TO T_COL; LET GU_DAT$[GU_R,1]=GCHD$[GU_R]; NEXT GU_R			
09140 FOR GU_R=1 TO T_COL; LET GU_DAT$[GU_R,2]=GDAT$[ROW_SEL,GU_R]; NEXT GU_R			
09145 GOSUB SUB_UTILITY_GU_RIGA_SHOW			
09150 RETURN 			
09155 SUB_UTILITY_GU_RIGA_SHOW: 			
09160 CALL "rbgmgd::sub_showgrd",GB__SYSGUI,GB__FORM_CONTEXT,GU_ID,T_COL,GU_DAT$[ALL],GU_PS$[ALL]			
09165 PRINT (GB__SYSGUI)'FLUSH',			
09170 RETURN 			
09175 SUB_LOAD_CUSTOM_UTENTE: 			
09180 LET COL_SEQ$=""; FOR COL=1 TO TOT_COL; LET COL_SEQ$=COL_SEQ$+STR(COL:"000"); NEXT COL			
09185 LET ACC$=STBL("acc",ERR=9220)			
09190 LET NRPGM$=STBL("nrpgm",ERR=9195)			
09195 LET NRPGM$=NRPGM$+FILL(4," "),NRPGM$=NRPGM$(1,4)			
09200 LET APP$=PGM(-2)+FILL(8," "),APP$=APP$(1,8)			
09205 LET K_US$="3"+ACC$(9,2)+ACC$(1,3)+APP$+NRPGM$			
09210 READ RECORD(106,KNUM=0,KEY=K_US$,DOM=9220,ERR=9220)REC$			
09215 LET COL_SEQ$=REC$(19)			
09220 REM ----			
09225 RETURN 			
09230 SUB_UTILITY_COL_UP: 			
09235 LET APP$=CTRL(GB__SYSGUI,1209,1); IF APP$(1,2)="00" THEN GOTO 9270			
09240 LET APP=POS(STR(NUM(APP$(1,2)):"000")=COL_SEQ$,3,1); IF APP<4 THEN GOTO 9270; 	REM non c'e' (??) o e' il primo-		
09245 LET AP1$=COL_SEQ$(APP-3,3)			
09250 LET COL_SEQ$(APP-3,3)=STR(NUM(APP$(1,2)):"000")			
09255 LET COL_SEQ$(APP,3)=AP1$			
09260 GOSUB SUB_GU_SHOW_RIGA			
09265 GOSUB SUB_UTILITY_GU_LOAD_LB			
09270 RETURN 			
09275 SUB_UTILITY_COL_DW: 			
09280 LET APP$=CTRL(GB__SYSGUI,1209,1); IF APP$(1,2)="00" THEN GOTO 9315			
09285 LET APP=POS(STR(NUM(APP$(1,2)):"000")=COL_SEQ$,3,1); IF APP=0 OR APP>LEN(COL_SEQ$)-4 THEN GOTO 9315; 	REM non c'e' (??) o e' l'ultimo-		
09290 LET AP1$=COL_SEQ$(APP+3,3)			
09295 LET COL_SEQ$(APP+3,3)=STR(NUM(APP$(1,2)):"000")			
09300 LET COL_SEQ$(APP,3)=AP1$			
09305 GOSUB SUB_GU_SHOW_RIGA			
09310 GOSUB SUB_UTILITY_GU_LOAD_LB			
09315 RETURN 			
09320 REM =====================================================================-			
09325 SUB_ROW_MOVE: 			
09330 REM ------------------------------------------------------------------			
09335 REM -- sposta il contenuto di una riga di una matrice in up or down-			
09340 REM -- > Matrice di lavoro-			
09345 REM -- > Riga da spostare-			
09350 REM -- > Direzione 1=up -1=dowm-			
09355 REM ------------------------------------------------------------------			
09360 SETERR SUBERR			
09365 ENTER GDAT$[ALL],ROW,TDIR			
09370 LET GDAT_ORG$[ALL]=GDAT$[ALL]			
09375 DIM DIMENSION$:"dimen:i(1),d0elem:i(4),d0base:i(4),d1elem:i(4),d1base:i(4),d2elem:i(4),d2base:i(4)"			
09380 LET DIMENSION$=DIMS(GDAT$[ALL]); LET TRIG=DIMENSION.D0ELEM-1; LET TCOL=DIMENSION.D1ELEM-1			
09385 REM ..mx_rig = ultima riga valida-			
09390 FOR APP=1 TO TRIG			
09395 LET APP$=""; FOR X=1 TO TCOL; LET APP$=APP$+GDAT$[APP,X]; NEXT X			
09400 IF LEN(CVS(APP$,35))>0 THEN LET MX_RIG=APP			
09405 NEXT APP			
09410 SWITCH TDIR			
09415 CASE 1; 	REM up-		
09420 IF ROW=1 THEN BREAK			
09425 FOR COL=1 TO TCOL; LET GDAT$[ROW-1,COL]=GDAT_ORG$[ROW,COL]; NEXT COL			
09430 FOR COL=1 TO TCOL; LET GDAT$[ROW,COL]=GDAT_ORG$[ROW-1,COL]; NEXT COL			
09435 BREAK			
09440 CASE -1; 	REM down-		
09445 IF ROW>=MX_RIG THEN BREAK			
09450 FOR COL=1 TO TCOL; LET GDAT$[ROW,COL]=GDAT_ORG$[ROW+1,COL]; NEXT COL			
09455 FOR COL=1 TO TCOL; LET GDAT$[ROW+1,COL]=GDAT_ORG$[ROW,COL]; NEXT COL			
09460 BREAK			
09465 SWEND			
09470 EXIT 			
09475 SUB_SET_RESIZE: 			
09480 REM Routine necessaria poiche i parametri attesi da sub_set_col_size-			
09485 REM  utilizzano variabili con nomi diversi-			
09490 FOR INDICE=1 TO GU_COL			
09495 LET MXCL=LEN(CVS(GU_HD$[INDICE],3)); FOR RW=1 TO GU_ROW; LET LEN_PXL=LEN(CVS(GU_DAT$[RW,INDICE],3)); IF LEN_PXL>MXCL THEN LET MXCL=LEN_PXL FI; NEXT RW			
09500 LET LEN_COLONNA=(MXCL+4)*COL_WIDTH+20			
09505 LET TF$=SENDMSG(GB__SYSGUI,GU_ID,36,INDICE-1,BIN(LEN_COLONNA,2))			
09510 NEXT INDICE			
09515 RETURN 			
54000 REM 54000-			
54010 SUBERR: 			
54020 LET MESSG$="Errore :"+STR(ERR)+$0A$			
54030 LET MESSG$=MESSG$+"Linea   :"+STR(TCB(5))+$0A$			
54040 LET MESSG$=MESSG$+"Contesto:"+STR(ACT_CTX)+$0A$			
54050 LET MESSG$=MESSG$+"Grid    :"+STR(GRID_ID)+$0A$			
54060 LET MESSG$=MESSG$+"Row     :"+STR(ROW)+$0A$			
54070 LET MESSG$=MESSG$+"col     :"+STR(COL)+$0A$			
54080 LET MESSG$=MESSG$+"tot_col :"+STR(TOT_COL)+$0A$			
54090 LET MESSG$=MESSG$+"tot_row :"+STR(TOT_ROW)+$0A$			
54100 LET MESSG$=MESSG$+"Dims gdat  col:"+STR(G_COL)+" row:"+STR(G_ROW)+$0A$			
54110 SETERR 54120; LET MESSG$=MESSG$+"Campo   :"+GDAT$[ROW,COL]+$0A$			
54120 SETERR SUBERR; LET MESSG$=MESSG$+"Row_top :"+STR(ROW_TOP)+$0A$			
54130 LET MESSG$=MESSG$+"Row_vis :"+STR(ROW_VIS)+$0A$			
54140 LET MESSG$=MESSG$+"HCol>cell :"+STR(CELL)+" len_hcol:"+STR(LEN_HCOL)+$0A$			
54150 LET MESSG$=MESSG$+"col_res_in:"+STR(COL_RES_IN)+$0A$			
54160 LET MESSG$=MESSG$+"col_res_fn:"+STR(COL_RES_FN)+$0A$			
54170 LET MESSG$=MESSG$+"t_ctr       :"+STR(T_CTR)+$0A$			
54180 LET MESSG$=MESSG$+"len str_sort:"+STR(LEN(STR_SORT$))+$0A$			
54190 LET MESSG$=MESSG$+"len stringa:"+STR(LEN(STRINGA$))+$0A$			
54200 LET MESSG$=MESSG$+"mx_len      :"+STR(MX_LEN)+$0A$			
54210 LET MESSG$=MESSG$+"len copy_of_str_org  :"+STR(LEN(COPY_OF_STR_ORG$))+$0A$			
54220 LET MESSG$=MESSG$+"ele  :"+STR(ELE)+$0A$			
54230 LET MESSG$=MESSG$+"indice "+STR(INDICE)+$0A$			
54240 LET MESSG$=MESSG$+"rw     "+STR(RW)+$0A$			
54250 LET X=MSGBOX(MESSG$,48,"smdVmgd - Informazioni aggiuntive")			
54260 LET APP$="rbgerr"			
54270 CALL APP$,ERR,TCB(5),STR(PGM(-2)),APP			
54280 IF REPORT_OPEN=1 THEN GOTO GRID_UTILITY_END			
54290 GOTO USCITA			
55000 REM 55000-			
55010 SUBESC: 			
55020 RETURN 			
56000 REM 56000-			
56010 SUBMESS: 			
56020 LET APP$="rbgmes"			
56030 CALL APP$,MESSG$,"1"			
56040 RETURN 			
